

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kafka Connect &mdash; Apache Kafka 4.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Apache Kafka 4.0.0 documentation" href="../index.html"/>
        <link rel="up" title="Apache Kafka Documentation" href="index.html"/>
        <link rel="prev" title="Security" href="security.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Apache Kafka
          

          
          </a>

          
            
            
              <div class="version">
                4.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../uses.html">Use Cases</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Apache Kafka Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html">Kafka APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="design.html">Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="implementation.html">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ops.html">Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html">Security</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Kafka Connect</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">8.1 Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-guide">8.2 User Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#running-kafka-connect">Running Kafka Connect</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuring-connectors">Configuring Connectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transformations">Transformations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rest-api">REST API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#connector-development-guide">8.3 Connector Development Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#core-concepts-and-apis">Core Concepts and APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#developing-a-simple-connector">Developing a Simple Connector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-input-output-streams">Dynamic Input/Output Streams</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connect-configuration-validation">Connect Configuration Validation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#working-with-schemas">Working with Schemas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kafka-connect-administration">Kafka Connect Administration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Apache Kafka</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Apache Kafka Documentation</a> &raquo;</li>
        
      <li>Kafka Connect</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/documentation/connect.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kafka-connect">
<h1>Kafka Connect<a class="headerlink" href="#kafka-connect" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id5">8.1 Overview</a></li>
<li><a class="reference internal" href="#user-guide" id="id6">8.2 User Guide</a><ul>
<li><a class="reference internal" href="#running-kafka-connect" id="id7">Running Kafka Connect</a></li>
<li><a class="reference internal" href="#configuring-connectors" id="id8">Configuring Connectors</a></li>
<li><a class="reference internal" href="#transformations" id="id9">Transformations</a></li>
<li><a class="reference internal" href="#rest-api" id="id10">REST API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#connector-development-guide" id="id11">8.3 Connector Development Guide</a><ul>
<li><a class="reference internal" href="#core-concepts-and-apis" id="id12">Core Concepts and APIs</a><ul>
<li><a class="reference internal" href="#connectors-and-tasks" id="id13">Connectors and Tasks</a></li>
<li><a class="reference internal" href="#streams-and-records" id="id14">Streams and Records</a></li>
<li><a class="reference internal" href="#dynamic-connectors" id="id15">Dynamic Connectors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#developing-a-simple-connector" id="id16">Developing a Simple Connector</a><ul>
<li><a class="reference internal" href="#connector-example" id="id17">Connector Example</a></li>
<li><a class="reference internal" href="#task-example-source-task" id="id18">Task Example - Source Task</a></li>
<li><a class="reference internal" href="#sink-tasks" id="id19">Sink Tasks</a></li>
<li><a class="reference internal" href="#resuming-from-previous-offsets" id="id20">Resuming from Previous Offsets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamic-input-output-streams" id="id21">Dynamic Input/Output Streams</a></li>
<li><a class="reference internal" href="#connect-configuration-validation" id="id22">Connect Configuration Validation</a></li>
<li><a class="reference internal" href="#working-with-schemas" id="id23">Working with Schemas</a></li>
<li><a class="reference internal" href="#kafka-connect-administration" id="id24">Kafka Connect Administration</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="reference external" href="#connect_overview">8.1 Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Kafka Connect is a tool for scalably and reliably streaming data between
Apache Kafka and other systems. It makes it simple to quickly define
<em>connectors</em> that move large collections of data into and out of Kafka.
Kafka Connect can ingest entire databases or collect metrics from all
your application servers into Kafka topics, making the data available
for stream processing with low latency. An export job can deliver data
from Kafka topics into secondary storage and query systems or into batch
systems for offline analysis.</p>
<p>Kafka Connect features include:</p>
<ul class="simple">
<li><strong>A common framework for Kafka connectors</strong> - Kafka Connect
standardizes integration of other data systems with Kafka,
simplifying connector development, deployment, and management</li>
<li><strong>Distributed and standalone modes</strong> - scale up to a large, centrally
managed service supporting an entire organization or scale down to
development, testing, and small production deployments</li>
<li><strong>REST interface</strong> - submit and manage connectors to your Kafka
Connect cluster via an easy to use REST API</li>
<li><strong>Automatic offset management</strong> - with just a little information from
connectors, Kafka Connect can manage the offset commit process
automatically so connector developers do not need to worry about this
error prone part of connector development</li>
<li><strong>Distributed and scalable by default</strong> - Kafka Connect builds on the
existing group management protocol. More workers can be added to
scale up a Kafka Connect cluster.</li>
<li><strong>Streaming/batch integration</strong> - leveraging Kafka&#8217;s existing
capabilities, Kafka Connect is an ideal solution for bridging
streaming and batch data systems</li>
</ul>
</div>
<div class="section" id="user-guide">
<h2><a class="reference external" href="#connect_user">8.2 User Guide</a><a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h2>
<p>The quickstart provides a brief example of how to run a standalone
version of Kafka Connect. This section describes how to configure, run,
and manage Kafka Connect in more detail.</p>
<div class="section" id="running-kafka-connect">
<h3><a class="reference external" href="#connect_running">Running Kafka Connect</a><a class="headerlink" href="#running-kafka-connect" title="Permalink to this headline">¶</a></h3>
<p>Kafka Connect currently supports two modes of execution: standalone
(single process) and distributed.</p>
<p>In standalone mode all work is performed in a single process. This
configuration is simpler to setup and get started with and may be useful
in situations where only one worker makes sense (e.g. collecting log
files), but it does not benefit from some of the features of Kafka
Connect such as fault tolerance. You can start a standalone process with
the following command:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="nb">bin</span><span class="o">/</span><span class="n">connect</span><span class="o">-</span><span class="n">standalone</span><span class="o">.</span><span class="n">sh</span> <span class="n">config</span><span class="o">/</span><span class="n">connect</span><span class="o">-</span><span class="n">standalone</span><span class="o">.</span><span class="n">properties</span> <span class="n">connector1</span><span class="o">.</span><span class="n">properties</span> <span class="p">[</span><span class="n">connector2</span><span class="o">.</span><span class="n">properties</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>The first parameter is the configuration for the worker. This includes
settings such as the Kafka connection parameters, serialization format,
and how frequently to commit offsets. The provided example should work
well with a local cluster running with the default configuration
provided by <code class="docutils literal"><span class="pre">config/server.properties</span></code>. It will require tweaking to
use with a different configuration or production deployment. All workers
(both standalone and distributed) require a few configs:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">bootstrap.servers</span></code> - List of Kafka servers used to bootstrap
connections to Kafka</li>
<li><code class="docutils literal"><span class="pre">key.converter</span></code> - Converter class used to convert between Kafka
Connect format and the serialized form that is written to Kafka. This
controls the format of the keys in messages written to or read from
Kafka, and since this is independent of connectors it allows any
connector to work with any serialization format. Examples of common
formats include JSON and Avro.</li>
<li><code class="docutils literal"><span class="pre">value.converter</span></code> - Converter class used to convert between Kafka
Connect format and the serialized form that is written to Kafka. This
controls the format of the values in messages written to or read from
Kafka, and since this is independent of connectors it allows any
connector to work with any serialization format. Examples of common
formats include JSON and Avro.</li>
</ul>
<p>The important configuration options specific to standalone mode are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">offset.storage.file.filename</span></code> - File to store offset data in</li>
</ul>
<p>The parameters that are configured here are intended for producers and
consumers used by Kafka Connect to access the configuration, offset and
status topics. For configuration of Kafka source and Kafka sink tasks,
the same parameters can be used but need to be prefixed with
<code class="docutils literal"><span class="pre">consumer.</span></code> and <code class="docutils literal"><span class="pre">producer.</span></code> respectively. The only parameter that is
inherited from the worker configuration is <code class="docutils literal"><span class="pre">bootstrap.servers</span></code>, which
in most cases will be sufficient, since the same cluster is often used
for all purposes. A notable exeption is a secured cluster, which
requires extra parameters to allow connections. These parameters will
need to be set up to three times in the worker configuration, once for
management access, once for Kafka sinks and once for Kafka sources.</p>
<p>The remaining parameters are connector configuration files. You may
include as many as you want, but all will execute within the same
process (on different threads).</p>
<p>Distributed mode handles automatic balancing of work, allows you to
scale up (or down) dynamically, and offers fault tolerance both in the
active tasks and for configuration and offset commit data. Execution is
very similar to standalone mode:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="nb">bin</span><span class="o">/</span><span class="n">connect</span><span class="o">-</span><span class="n">distributed</span><span class="o">.</span><span class="n">sh</span> <span class="n">config</span><span class="o">/</span><span class="n">connect</span><span class="o">-</span><span class="n">distributed</span><span class="o">.</span><span class="n">properties</span>
</pre></div>
</div>
<p>The difference is in the class which is started and the configuration
parameters which change how the Kafka Connect process decides where to
store configurations, how to assign work, and where to store offsets and
task statues. In the distributed mode, Kafka Connect stores the offsets,
configs and task statuses in Kafka topics. It is recommended to manually
create the topics for offset, configs and statuses in order to achieve
the desired the number of partitions and replication factors. If the
topics are not yet created when starting Kafka Connect, the topics will
be auto created with default number of partitions and replication
factor, which may not be best suited for its usage.</p>
<p>In particular, the following configuration parameters, in addition to
the common settings mentioned above, are critical to set before starting
your cluster:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">group.id</span></code> (default <code class="docutils literal"><span class="pre">connect-cluster</span></code>) - unique name for the
cluster, used in forming the Connect cluster group; note that this
<strong>must not conflict</strong> with consumer group IDs</li>
<li><code class="docutils literal"><span class="pre">config.storage.topic</span></code> (default <code class="docutils literal"><span class="pre">connect-configs</span></code>) - topic to use
for storing connector and task configurations; note that this should
be a single partition, highly replicated, compacted topic. You may
need to manually create the topic to ensure the correct configuration
as auto created topics may have multiple partitions or be
automatically configured for deletion rather than compaction</li>
<li><code class="docutils literal"><span class="pre">offset.storage.topic</span></code> (default <code class="docutils literal"><span class="pre">connect-offsets</span></code>) - topic to use
for storing offsets; this topic should have many partitions, be
replicated, and be configured for compaction</li>
<li><code class="docutils literal"><span class="pre">status.storage.topic</span></code> (default <code class="docutils literal"><span class="pre">connect-status</span></code>) - topic to use
for storing statuses; this topic can have multiple partitions, and
should be replicated and configured for compaction</li>
</ul>
<p>Note that in distributed mode the connector configurations are not
passed on the command line. Instead, use the REST API described below to
create, modify, and destroy connectors.</p>
</div>
<div class="section" id="configuring-connectors">
<h3><a class="reference external" href="#connect_configuring">Configuring Connectors</a><a class="headerlink" href="#configuring-connectors" title="Permalink to this headline">¶</a></h3>
<p>Connector configurations are simple key-value mappings. For standalone
mode these are defined in a properties file and passed to the Connect
process on the command line. In distributed mode, they will be included
in the JSON payload for the request that creates (or modifies) the
connector.</p>
<p>Most configurations are connector dependent, so they can&#8217;t be outlined
here. However, there are a few common options:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">name</span></code> - Unique name for the connector. Attempting to register
again with the same name will fail.</li>
<li><code class="docutils literal"><span class="pre">connector.class</span></code> - The Java class for the connector</li>
<li><code class="docutils literal"><span class="pre">tasks.max</span></code> - The maximum number of tasks that should be created
for this connector. The connector may create fewer tasks if it cannot
achieve this level of parallelism.</li>
<li><code class="docutils literal"><span class="pre">key.converter</span></code> - (optional) Override the default key converter set
by the worker.</li>
<li><code class="docutils literal"><span class="pre">value.converter</span></code> - (optional) Override the default value converter
set by the worker.</li>
</ul>
<p>The <code class="docutils literal"><span class="pre">connector.class</span></code> config supports several formats: the full name
or alias of the class for this connector. If the connector is
org.apache.kafka.connect.file.FileStreamSinkConnector, you can either
specify this full name or use FileStreamSink or FileStreamSinkConnector
to make the configuration a bit shorter.</p>
<p>Sink connectors also have a few additional options to control their
input. Each sink connector must set one of the following:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">topics</span></code> - A comma-separated list of topics to use as input for
this connector</li>
<li><code class="docutils literal"><span class="pre">topics.regex</span></code> - A Java regular expression of topics to use as
input for this connector</li>
</ul>
<p>For any other options, you should consult the documentation for the
connector.</p>
</div>
<div class="section" id="transformations">
<h3><a class="reference external" href="#connect_transforms">Transformations</a><a class="headerlink" href="#transformations" title="Permalink to this headline">¶</a></h3>
<p>Connectors can be configured with transformations to make lightweight
message-at-a-time modifications. They can be convenient for data
massaging and event routing.</p>
<p>A transformation chain can be specified in the connector configuration.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">transforms</span></code> - List of aliases for the transformation, specifying
the order in which the transformations will be applied.</li>
<li><code class="docutils literal"><span class="pre">transforms.$alias.type</span></code> - Fully qualified class name for the
transformation.</li>
<li><code class="docutils literal"><span class="pre">transforms.$alias.$transformationSpecificConfig</span></code> Configuration
properties for the transformation</li>
</ul>
<p>For example, lets take the built-in file source connector and use a
transformation to add a static field.</p>
<p>Throughout the example we&#8217;ll use schemaless JSON data format. To use
schemaless format, we changed the following two lines in
<code class="docutils literal"><span class="pre">connect-standalone.properties</span></code> from true to false:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">key</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">schemas</span><span class="o">.</span><span class="n">enable</span>
<span class="n">value</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">schemas</span><span class="o">.</span><span class="n">enable</span>
</pre></div>
</div>
<p>The file source connector reads each line as a String. We will wrap each
line in a Map and then add a second field to identify the origin of the
event. To do this, we use two transformations:</p>
<ul class="simple">
<li><strong>HoistField</strong> to place the input line inside a Map</li>
<li><strong>InsertField</strong> to add the static field. In this example we&#8217;ll
indicate that the record came from a file connector</li>
</ul>
<p>After adding the transformations, <code class="docutils literal"><span class="pre">connect-file-source.properties</span></code>
file looks as following:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span>name=local-file-source
connector.class=FileStreamSource
tasks.max=1
file=test.txt
topic=connect-test
transforms=MakeMap, InsertSource
transforms.MakeMap.type=org.apache.kafka.connect.transforms.HoistField$Value
transforms.MakeMap.field=line
transforms.InsertSource.type=org.apache.kafka.connect.transforms.InsertField$Value
transforms.InsertSource.static.field=data_source
transforms.InsertSource.static.value=test-file-source
</pre></div>
</div>
<p>All the lines starting with <code class="docutils literal"><span class="pre">transforms</span></code> were added for the
transformations. You can see the two transformations we created:
&#8220;InsertSource&#8221; and &#8220;MakeMap&#8221; are aliases that we chose to give the
transformations. The transformation types are based on the list of
built-in transformations you can see below. Each transformation type has
additional configuration: HoistField requires a configuration called
&#8220;field&#8221;, which is the name of the field in the map that will include the
original String from the file. InsertField transformation lets us
specify the field name and the value that we are adding.</p>
<p>When we ran the file source connector on my sample file without the
transformations, and then read them using <code class="docutils literal"><span class="pre">kafka-console-consumer.sh</span></code>,
the results were:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;foo&quot;</span>
<span class="s2">&quot;bar&quot;</span>
<span class="s2">&quot;hello world&quot;</span>
</pre></div>
</div>
<p>We then create a new file connector, this time after adding the
transformations to the configuration file. This time, the results will
be:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;line&quot;</span><span class="p">:</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span><span class="s2">&quot;data_source&quot;</span><span class="p">:</span><span class="s2">&quot;test-file-source&quot;</span><span class="p">}</span>
<span class="p">{</span><span class="s2">&quot;line&quot;</span><span class="p">:</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span><span class="s2">&quot;data_source&quot;</span><span class="p">:</span><span class="s2">&quot;test-file-source&quot;</span><span class="p">}</span>
<span class="p">{</span><span class="s2">&quot;line&quot;</span><span class="p">:</span><span class="s2">&quot;hello world&quot;</span><span class="p">,</span><span class="s2">&quot;data_source&quot;</span><span class="p">:</span><span class="s2">&quot;test-file-source&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>You can see that the lines we&#8217;ve read are now part of a JSON map, and
there is an extra field with the static value we specified. This is just
one example of what you can do with transformations.</p>
<p>Several widely-applicable data and routing transformations are included
with Kafka Connect:</p>
<ul class="simple">
<li>InsertField - Add a field using either static data or record metadata</li>
<li>ReplaceField - Filter or rename fields</li>
<li>MaskField - Replace field with valid null value for the type (0,
empty string, etc)</li>
<li>ValueToKey</li>
<li>HoistField - Wrap the entire event as a single field inside a Struct
or a Map</li>
<li>ExtractField - Extract a specific field from Struct and Map and
include only this field in results</li>
<li>SetSchemaMetadata - modify the schema name or version</li>
<li>TimestampRouter - Modify the topic of a record based on original
topic and timestamp. Useful when using a sink that needs to write to
different tables or indexes based on timestamps</li>
<li>RegexRouter - modify the topic of a record based on original topic,
replacement string and a regular expression</li>
</ul>
<p>Details on how to configure each transformation are listed below:</p>
<div id="org.apache.kafka.connect.transforms.InsertField"><p class="rubric" id="org-apache-kafka-connect-transforms-insertfield">org.apache.kafka.connect.transforms.InsertField</p>
<p>Insert field(s) using attributes from the record metadata or a
configured static value.</p>
<p>Use the concrete transformation type designed for the record key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.InsertField$Key</span></code>) or value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.InsertField$Value</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>offset.fi
eld</td>
<td>Field
name for
Kafka
offset -
only
applicabl
e
to sink
connector
s.
Suffix
with
<code class="docutils literal"><span class="pre">!</span></code> to
make this
a
required
field, or
<code class="docutils literal"><span class="pre">?</span></code> to
keep it
optional
(the
default).</td>
<td>string</td>
<td>null</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
<tr class="row-odd"><td>partition
.field</td>
<td>Field
name for
Kafka
partition
.
Suffix
with
<code class="docutils literal"><span class="pre">!</span></code> to
make this
a
required
field, or
<code class="docutils literal"><span class="pre">?</span></code> to
keep it
optional
(the
default).</td>
<td>string</td>
<td>null</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
<tr class="row-even"><td>static.fi
eld</td>
<td>Field
name for
static
data
field.
Suffix
with
<code class="docutils literal"><span class="pre">!</span></code> to
make this
a
required
field, or
<code class="docutils literal"><span class="pre">?</span></code> to
keep it
optional
(the
default).</td>
<td>string</td>
<td>null</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
<tr class="row-odd"><td>static.va
lue</td>
<td>Static
field
value, if
field
name
configure
d.</td>
<td>string</td>
<td>null</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
<tr class="row-even"><td>timestamp
.field</td>
<td>Field
name for
record
timestamp
.
Suffix
with
<code class="docutils literal"><span class="pre">!</span></code> to
make this
a
required
field, or
<code class="docutils literal"><span class="pre">?</span></code> to
keep it
optional
(the
default).</td>
<td>string</td>
<td>null</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
<tr class="row-odd"><td>topic.fie
ld</td>
<td>Field
name for
Kafka
topic.
Suffix
with
<code class="docutils literal"><span class="pre">!</span></code> to
make this
a
required
field, or
<code class="docutils literal"><span class="pre">?</span></code> to
keep it
optional
(the
default).</td>
<td>string</td>
<td>null</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.ReplaceField"><p class="rubric" id="org-apache-kafka-connect-transforms-replacefield">org.apache.kafka.connect.transforms.ReplaceField</p>
<p>Filter or rename fields.</p>
<p>Use the concrete transformation type designed for the record key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.ReplaceField$Key</span></code>) or value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.ReplaceField$Value</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>blacklist</td>
<td>Fields to
exclude.
This
takes
precedenc
e
over the
whitelist
.</td>
<td>list</td>
<td>&#8220;&#8221;</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
<tr class="row-odd"><td>renames</td>
<td>Field
rename
mappings.</td>
<td>list</td>
<td>&#8220;&#8221;</td>
<td>list of
colon-del
imited
pairs,
e.g.
<a href="#id1"><span class="problematic" id="id2">``</span></a>foo:bar
,abc:xyz`
`</td>
<td>medium</td>
</tr>
<tr class="row-even"><td>whitelist</td>
<td>Fields to
include.
If
specified
,
only
these
fields
will be
used.</td>
<td>list</td>
<td>&#8220;&#8221;</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.MaskField"><p class="rubric" id="org-apache-kafka-connect-transforms-maskfield">org.apache.kafka.connect.transforms.MaskField</p>
<p>Mask specified fields with a valid null value for the field type (i.e.
0, false, empty string, and so on).</p>
<p>Use the concrete transformation type designed for the record key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.MaskField$Key</span></code>) or value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.MaskField$Value</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="34%" />
<col width="8%" />
<col width="12%" />
<col width="21%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid Values</th>
<th class="head">Importance</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>fields</td>
<td>Names of fields to mask.</td>
<td>list</td>
<td>&nbsp;</td>
<td>non-empty list</td>
<td>high</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.ValueToKey"><p class="rubric" id="org-apache-kafka-connect-transforms-valuetokey">org.apache.kafka.connect.transforms.ValueToKey</p>
<p>Replace the record key with a new key formed from a subset of fields in
the record value.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>fields</td>
<td>Field
names on
the
record
value to
extract
as the
record
key.</td>
<td>list</td>
<td>&nbsp;</td>
<td>non-empty
list</td>
<td>high</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.HoistField"><p class="rubric" id="org-apache-kafka-connect-transforms-hoistfield">org.apache.kafka.connect.transforms.HoistField</p>
<p>Wrap data using the specified field name in a Struct when schema
present, or a Map in the case of schemaless data.</p>
<p>Use the concrete transformation type designed for the record key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.HoistField$Key</span></code>) or value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.HoistField$Value</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>field</td>
<td>Field
name for
the
single
field
that will
be
created
in the
resulting
Struct or
Map.</td>
<td>string</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.ExtractField"><p class="rubric" id="org-apache-kafka-connect-transforms-extractfield">org.apache.kafka.connect.transforms.ExtractField</p>
<p>Extract the specified field from a Struct when schema present, or a Map
in the case of schemaless data. Any null values are passed through
unmodified.</p>
<p>Use the concrete transformation type designed for the record key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.ExtractField$Key</span></code>) or value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.ExtractField$Value</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="32%" />
<col width="11%" />
<col width="12%" />
<col width="19%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid Values</th>
<th class="head">Importance</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>field</td>
<td>Field name to extract.</td>
<td>string</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.SetSchemaMetadata"><p class="rubric" id="org-apache-kafka-connect-transforms-setschemametadata">org.apache.kafka.connect.transforms.SetSchemaMetadata</p>
<p>Set the schema name, version or both on the record&#8217;s key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.SetSchemaMetadata$Key</span></code>) or value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.SetSchemaMetadata$Value</span></code>)
schema.</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="29%" />
<col width="10%" />
<col width="11%" />
<col width="17%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid Values</th>
<th class="head">Importance</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>schema.name</td>
<td>Schema name to set.</td>
<td>string</td>
<td>null</td>
<td>&nbsp;</td>
<td>high</td>
</tr>
<tr class="row-odd"><td>schema.version</td>
<td>Schema version to set.</td>
<td>int</td>
<td>null</td>
<td>&nbsp;</td>
<td>high</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.TimestampRouter"><p class="rubric" id="org-apache-kafka-connect-transforms-timestamprouter">org.apache.kafka.connect.transforms.TimestampRouter</p>
<p>Update the record&#8217;s topic field as a function of the original topic
value and the record timestamp.</p>
<p>This is mainly useful for sink connectors, since the topic field is
often used to determine the equivalent entity name in the destination
system(e.g. database table or search index name).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>timestamp
.format</td>
<td>Format
string
for the
timestamp
that is
compatibl
e
with
<code class="docutils literal"><span class="pre">java.te</span>
<span class="pre">xt.Simple</span>
<span class="pre">DateForma</span>
<span class="pre">t</span></code>.</td>
<td>string</td>
<td>yyyyMMdd</td>
<td>&nbsp;</td>
<td>high</td>
</tr>
<tr class="row-odd"><td>topic.for
mat</td>
<td>Format
string
which can
contain
<code class="docutils literal"><span class="pre">${topic</span>
<span class="pre">}</span></code>
and
<code class="docutils literal"><span class="pre">${times</span>
<span class="pre">tamp}</span></code>
as
placehold
ers
for the
topic and
timestamp
,
respectiv
ely.</td>
<td>string</td>
<td>${topic}-
${timesta
mp}</td>
<td>&nbsp;</td>
<td>high</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.RegexRouter"><p class="rubric" id="org-apache-kafka-connect-transforms-regexrouter">org.apache.kafka.connect.transforms.RegexRouter</p>
<p>Update the record topic using the configured regular expression and
replacement string.</p>
<p>Under the hood, the regex is compiled to a <code class="docutils literal"><span class="pre">java.util.regex.Pattern</span></code>.
If the pattern matches the input topic,
<code class="docutils literal"><span class="pre">java.util.regex.Matcher#replaceFirst()</span></code> is used with the replacement
string to obtain the new topic.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>regex</td>
<td>Regular
expressio
n
to use
for
matching.</td>
<td>string</td>
<td>&nbsp;</td>
<td>valid
regex</td>
<td>high</td>
</tr>
<tr class="row-odd"><td>replaceme
nt</td>
<td>Replaceme
nt
string.</td>
<td>string</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>high</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.Flatten"><p class="rubric" id="org-apache-kafka-connect-transforms-flatten">org.apache.kafka.connect.transforms.Flatten</p>
<p>Flatten a nested data structure, generating names for each field by
concatenating the field names at each level with a configurable
delimiter character. Applies to Struct when schema present, or a Map in
the case of schemaless data. The default delimiter is &#8216;.&#8217;.</p>
<p>Use the concrete transformation type designed for the record key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.Flatten$Key</span></code>) or value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.Flatten$Value</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>delimiter</td>
<td>Delimiter
to insert
between
field
names
from the
input
record
when
generatin
g
field
names for
the
output
record</td>
<td>string</td>
<td>.</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.Cast"><p class="rubric" id="org-apache-kafka-connect-transforms-cast">org.apache.kafka.connect.transforms.Cast</p>
<p>Cast fields or the entire key or value to a specific type, e.g. to force
an integer field to a smaller width. Only simple primitive types are
supported &#8211; integers, floats, boolean, and string.</p>
<p>Use the concrete transformation type designed for the record key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.Cast$Key</span></code>) or value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.Cast$Value</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>spec</td>
<td>List of
fields
and the
type to
cast them
to of the
form
field1:ty
pe,field2
:type
to cast
fields of
Maps or
Structs.
A single
type to
cast the
entire
value.
Valid
types are
int8,
int16,
int32,
int64,
float32,
float64,
boolean,
and
string.</td>
<td>list</td>
<td>&nbsp;</td>
<td>list of
colon-del
imited
pairs,
e.g.
<a href="#id3"><span class="problematic" id="id4">``</span></a>foo:bar
,abc:xyz`
`</td>
<td>high</td>
</tr>
</tbody>
</table>
</div><div id="org.apache.kafka.connect.transforms.TimestampConverter"><p class="rubric" id="org-apache-kafka-connect-transforms-timestampconverter">org.apache.kafka.connect.transforms.TimestampConverter</p>
<p>Convert timestamps between different formats such as Unix epoch,
strings, and Connect Date/Timestamp types.Applies to individual fields
or to the entire value.</p>
<p>Use the concrete transformation type designed for the record key
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.TimestampConverter$Key</span></code>) or
value
(<code class="docutils literal"><span class="pre">org.apache.kafka.connect.transforms.TimestampConverter$Value</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Descripti
on</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Valid
Values</th>
<th class="head">Importanc
e</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>target.ty
pe</td>
<td>The
desired
timestamp
represent
ation:
string,
unix,
Date,
Time, or
Timestamp</td>
<td>string</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>high</td>
</tr>
<tr class="row-odd"><td>field</td>
<td>The field
containin
g
the
timestamp
,
or empty
if the
entire
value is
a
timestamp</td>
<td>string</td>
<td>&#8220;&#8221;</td>
<td>&nbsp;</td>
<td>high</td>
</tr>
<tr class="row-even"><td>format</td>
<td>A
SimpleDat
eFormat-c
ompatible
format
for the
timestamp
.
Used to
generate
the
output
when
type=stri
ng
or used
to parse
the input
if the
input is
a string.</td>
<td>string</td>
<td>&#8220;&#8221;</td>
<td>&nbsp;</td>
<td>medium</td>
</tr>
</tbody>
</table>
</div></div>
<div class="section" id="rest-api">
<h3><a class="reference external" href="#connect_rest">REST API</a><a class="headerlink" href="#rest-api" title="Permalink to this headline">¶</a></h3>
<p>Since Kafka Connect is intended to be run as a service, it also provides
a REST API for managing connectors. The REST API server can be
configured using the <code class="docutils literal"><span class="pre">listeners</span></code> configuration option. This field
should contain a list of listeners in the following format:
<code class="docutils literal"><span class="pre">protocol://host:port,protocol2://host2:port2</span></code>. Currently supported
protocols are <code class="docutils literal"><span class="pre">http</span></code> and <code class="docutils literal"><span class="pre">https</span></code>. For example:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">listeners</span><span class="o">=</span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">localhost</span><span class="p">:</span><span class="mi">8080</span><span class="p">,</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">localhost</span><span class="p">:</span><span class="mi">8443</span>
</pre></div>
</div>
<p>By default, if no <code class="docutils literal"><span class="pre">listeners</span></code> are specified, the REST server runs on
port 8083 using the HTTP protocol. When using HTTPS, the configuration
has to include the SSL configuration. By default, it will use the
<code class="docutils literal"><span class="pre">ssl.*</span></code> settings. In case it is needed to use different configuration
for the REST API than for connecting to Kafka brokers, the fields can be
prefixed with <code class="docutils literal"><span class="pre">listeners.https</span></code>. When using the prefix, only the
prefixed options will be used and the <code class="docutils literal"><span class="pre">ssl.*</span></code> options without the
prefix will be ignored. Following fields can be used to configure HTTPS
for the REST API:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ssl.keystore.location</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.keystore.password</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.keystore.type</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.key.password</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.truststore.location</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.truststore.password</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.truststore.type</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.enabled.protocols</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.provider</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.protocol</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.cipher.suites</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.keymanager.algorithm</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.secure.random.implementation</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.trustmanager.algorithm</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.endpoint.identification.algorithm</span></code></li>
<li><code class="docutils literal"><span class="pre">ssl.client.auth</span></code></li>
</ul>
<p>The REST API is used not only by users to monitor / manage Kafka
Connect. It is also used for the Kafka Connect cross-cluster
communication. Requests received on the follower nodes REST API will be
forwarded to the leader node REST API. In case the URI under which is
given host reachable is different from the URI which it listens on, the
configuration options <code class="docutils literal"><span class="pre">rest.advertised.host.name</span></code>,
<code class="docutils literal"><span class="pre">rest.advertised.port</span></code> and <code class="docutils literal"><span class="pre">rest.advertised.listener</span></code> can be used to
change the URI which will be used by the follower nodes to connect with
the leader. When using both HTTP and HTTPS listeners, the
<code class="docutils literal"><span class="pre">rest.advertised.listener</span></code> option can be also used to define which
listener will be used for the cross-cluster communication. When using
HTTPS for communication between nodes, the same <code class="docutils literal"><span class="pre">ssl.*</span></code> or
<code class="docutils literal"><span class="pre">listeners.https</span></code> options will be used to configure the HTTPS client.</p>
<p>The following are the currently supported REST API endpoints:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">GET</span> <span class="pre">/connectors</span></code> - return a list of active connectors</li>
<li><code class="docutils literal"><span class="pre">POST</span> <span class="pre">/connectors</span></code> - create a new connector; the request body
should be a JSON object containing a string <code class="docutils literal"><span class="pre">name</span></code> field and an
object <code class="docutils literal"><span class="pre">config</span></code> field with the connector configuration parameters</li>
<li><code class="docutils literal"><span class="pre">GET</span> <span class="pre">/connectors/{name}</span></code> - get information about a specific
connector</li>
<li><code class="docutils literal"><span class="pre">GET</span> <span class="pre">/connectors/{name}/config</span></code> - get the configuration parameters
for a specific connector</li>
<li><code class="docutils literal"><span class="pre">PUT</span> <span class="pre">/connectors/{name}/config</span></code> - update the configuration
parameters for a specific connector</li>
<li><code class="docutils literal"><span class="pre">GET</span> <span class="pre">/connectors/{name}/status</span></code> - get current status of the
connector, including if it is running, failed, paused, etc., which
worker it is assigned to, error information if it has failed, and the
state of all its tasks</li>
<li><code class="docutils literal"><span class="pre">GET</span> <span class="pre">/connectors/{name}/tasks</span></code> - get a list of tasks currently
running for a connector</li>
<li><code class="docutils literal"><span class="pre">GET</span> <span class="pre">/connectors/{name}/tasks/{taskid}/status</span></code> - get current status
of the task, including if it is running, failed, paused, etc., which
worker it is assigned to, and error information if it has failed</li>
<li><code class="docutils literal"><span class="pre">PUT</span> <span class="pre">/connectors/{name}/pause</span></code> - pause the connector and its tasks,
which stops message processing until the connector is resumed</li>
<li><code class="docutils literal"><span class="pre">PUT</span> <span class="pre">/connectors/{name}/resume</span></code> - resume a paused connector (or do
nothing if the connector is not paused)</li>
<li><code class="docutils literal"><span class="pre">POST</span> <span class="pre">/connectors/{name}/restart</span></code> - restart a connector (typically
because it has failed)</li>
<li><code class="docutils literal"><span class="pre">POST</span> <span class="pre">/connectors/{name}/tasks/{taskId}/restart</span></code> - restart an
individual task (typically because it has failed)</li>
<li><code class="docutils literal"><span class="pre">DELETE</span> <span class="pre">/connectors/{name}</span></code> - delete a connector, halting all tasks
and deleting its configuration</li>
</ul>
<p>Kafka Connect also provides a REST API for getting information about
connector plugins:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">GET</span> <span class="pre">/connector-plugins</span></code>- return a list of connector plugins
installed in the Kafka Connect cluster. Note that the API only checks
for connectors on the worker that handles the request, which means
you may see inconsistent results, especially during a rolling upgrade
if you add new connector jars</li>
<li><code class="docutils literal"><span class="pre">PUT</span> <span class="pre">/connector-plugins/{connector-type}/config/validate</span></code> -
validate the provided configuration values against the configuration
definition. This API performs per config validation, returns
suggested values and error messages during validation.</li>
</ul>
</div>
</div>
<div class="section" id="connector-development-guide">
<h2><a class="reference external" href="#connect_development">8.3 Connector Development Guide</a><a class="headerlink" href="#connector-development-guide" title="Permalink to this headline">¶</a></h2>
<p>This guide describes how developers can write new connectors for Kafka
Connect to move data between Kafka and other systems. It briefly reviews
a few key concepts and then describes how to create a simple connector.</p>
<div class="section" id="core-concepts-and-apis">
<h3><a class="reference external" href="#connect_concepts">Core Concepts and APIs</a><a class="headerlink" href="#core-concepts-and-apis" title="Permalink to this headline">¶</a></h3>
<div class="section" id="connectors-and-tasks">
<h4><a class="reference external" href="#connect_connectorsandtasks">Connectors and Tasks</a><a class="headerlink" href="#connectors-and-tasks" title="Permalink to this headline">¶</a></h4>
<p>To copy data between Kafka and another system, users create a
<code class="docutils literal"><span class="pre">Connector</span></code> for the system they want to pull data from or push data
to. Connectors come in two flavors: <code class="docutils literal"><span class="pre">SourceConnectors</span></code> import data
from another system (e.g. <code class="docutils literal"><span class="pre">JDBCSourceConnector</span></code> would import a
relational database into Kafka) and <code class="docutils literal"><span class="pre">SinkConnectors</span></code> export data (e.g.
<code class="docutils literal"><span class="pre">HDFSSinkConnector</span></code> would export the contents of a Kafka topic to an
HDFS file).</p>
<p><code class="docutils literal"><span class="pre">Connectors</span></code> do not perform any data copying themselves: their
configuration describes the data to be copied, and the <code class="docutils literal"><span class="pre">Connector</span></code> is
responsible for breaking that job into a set of <code class="docutils literal"><span class="pre">Tasks</span></code> that can be
distributed to workers. These <code class="docutils literal"><span class="pre">Tasks</span></code> also come in two corresponding
flavors: <code class="docutils literal"><span class="pre">SourceTask</span></code> and <code class="docutils literal"><span class="pre">SinkTask</span></code>.</p>
<p>With an assignment in hand, each <code class="docutils literal"><span class="pre">Task</span></code> must copy its subset of the
data to or from Kafka. In Kafka Connect, it should always be possible to
frame these assignments as a set of input and output streams consisting
of records with consistent schemas. Sometimes this mapping is obvious:
each file in a set of log files can be considered a stream with each
parsed line forming a record using the same schema and offsets stored as
byte offsets in the file. In other cases it may require more effort to
map to this model: a JDBC connector can map each table to a stream, but
the offset is less clear. One possible mapping uses a timestamp column
to generate queries incrementally returning new data, and the last
queried timestamp can be used as the offset.</p>
</div>
<div class="section" id="streams-and-records">
<h4><a class="reference external" href="#connect_streamsandrecords">Streams and Records</a><a class="headerlink" href="#streams-and-records" title="Permalink to this headline">¶</a></h4>
<p>Each stream should be a sequence of key-value records. Both the keys and
values can have complex structure &#8211; many primitive types are provided,
but arrays, objects, and nested data structures can be represented as
well. The runtime data format does not assume any particular
serialization format; this conversion is handled internally by the
framework.</p>
<p>In addition to the key and value, records (both those generated by
sources and those delivered to sinks) have associated stream IDs and
offsets. These are used by the framework to periodically commit the
offsets of data that have been processed so that in the event of
failures, processing can resume from the last committed offsets,
avoiding unnecessary reprocessing and duplication of events.</p>
</div>
<div class="section" id="dynamic-connectors">
<h4><a class="reference external" href="#connect_dynamicconnectors">Dynamic Connectors</a><a class="headerlink" href="#dynamic-connectors" title="Permalink to this headline">¶</a></h4>
<p>Not all jobs are static, so <code class="docutils literal"><span class="pre">Connector</span></code> implementations are also
responsible for monitoring the external system for any changes that
might require reconfiguration. For example, in the
<code class="docutils literal"><span class="pre">JDBCSourceConnector</span></code> example, the <code class="docutils literal"><span class="pre">Connector</span></code> might assign a set of
tables to each <code class="docutils literal"><span class="pre">Task</span></code>. When a new table is created, it must discover
this so it can assign the new table to one of the <code class="docutils literal"><span class="pre">Tasks</span></code> by updating
its configuration. When it notices a change that requires
reconfiguration (or a change in the number of <code class="docutils literal"><span class="pre">Tasks</span></code>), it notifies
the framework and the framework updates any corresponding <code class="docutils literal"><span class="pre">Tasks</span></code>.</p>
</div>
</div>
<div class="section" id="developing-a-simple-connector">
<h3><a class="reference external" href="#connect_developing">Developing a Simple Connector</a><a class="headerlink" href="#developing-a-simple-connector" title="Permalink to this headline">¶</a></h3>
<p>Developing a connector only requires implementing two interfaces, the
<code class="docutils literal"><span class="pre">Connector</span></code> and <code class="docutils literal"><span class="pre">Task</span></code>. A simple example is included with the source
code for Kafka in the <code class="docutils literal"><span class="pre">file</span></code> package. This connector is meant for use
in standalone mode and has implementations of a
<code class="docutils literal"><span class="pre">SourceConnector</span></code>/<code class="docutils literal"><span class="pre">SourceTask</span></code> to read each line of a file and emit
it as a record and a <code class="docutils literal"><span class="pre">SinkConnector</span></code>/<code class="docutils literal"><span class="pre">SinkTask</span></code> that writes each
record to a file.</p>
<p>The rest of this section will walk through some code to demonstrate the
key steps in creating a connector, but developers should also refer to
the full example source code as many details are omitted for brevity.</p>
<div class="section" id="connector-example">
<h4><a class="reference external" href="#connect_connectorexample">Connector Example</a><a class="headerlink" href="#connector-example" title="Permalink to this headline">¶</a></h4>
<p>We&#8217;ll cover the <code class="docutils literal"><span class="pre">SourceConnector</span></code> as a simple example.
<code class="docutils literal"><span class="pre">SinkConnector</span></code> implementations are very similar. Start by creating
the class that inherits from <code class="docutils literal"><span class="pre">SourceConnector</span></code> and add a couple of
fields that will store parsed configuration information (the filename to
read from and the topic to send data to):</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">FileStreamSourceConnector</span> <span class="n">extends</span> <span class="n">SourceConnector</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">String</span> <span class="n">filename</span><span class="p">;</span>
    <span class="n">private</span> <span class="n">String</span> <span class="n">topic</span><span class="p">;</span>
</pre></div>
</div>
<p>The easiest method to fill in is <code class="docutils literal"><span class="pre">taskClass()</span></code>, which defines the
class that should be instantiated in worker processes to actually read
the data:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span>@Override
public Class&lt;? extends Task&gt; taskClass() {
    return FileStreamSourceTask.class;
}
</pre></div>
</div>
<p>We will define the <code class="docutils literal"><span class="pre">FileStreamSourceTask</span></code> class below. Next, we add
some standard lifecycle methods, <code class="docutils literal"><span class="pre">start()</span></code> and <code class="docutils literal"><span class="pre">stop()</span></code></p>
<p>:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="nd">@Override</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">start</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">complete</span> <span class="n">version</span> <span class="n">includes</span> <span class="n">error</span> <span class="n">handling</span> <span class="k">as</span> <span class="n">well</span><span class="o">.</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">FILE_CONFIG</span><span class="p">);</span>
    <span class="n">topic</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">TOPIC_CONFIG</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">@Override</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Nothing</span> <span class="n">to</span> <span class="n">do</span> <span class="n">since</span> <span class="n">no</span> <span class="n">background</span> <span class="n">monitoring</span> <span class="ow">is</span> <span class="n">required</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, the real core of the implementation is in <code class="docutils literal"><span class="pre">taskConfigs()</span></code>. In
this case we are only handling a single file, so even though we may be
permitted to generate more tasks as per the <code class="docutils literal"><span class="pre">maxTasks</span></code> argument, we
return a list with only one entry:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="nd">@Override</span>
<span class="n">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">taskConfigs</span><span class="p">(</span><span class="nb">int</span> <span class="n">maxTasks</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">configs</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="o">//</span> <span class="n">Only</span> <span class="n">one</span> <span class="nb">input</span> <span class="n">stream</span> <span class="n">makes</span> <span class="n">sense</span><span class="o">.</span>
    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">config</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">filename</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">FILE_CONFIG</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
    <span class="n">config</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">TOPIC_CONFIG</span><span class="p">,</span> <span class="n">topic</span><span class="p">);</span>
    <span class="n">configs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">configs</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Although not used in the example, <code class="docutils literal"><span class="pre">SourceTask</span></code> also provides two APIs
to commit offsets in the source system: <code class="docutils literal"><span class="pre">commit</span></code> and <code class="docutils literal"><span class="pre">commitRecord</span></code>.
The APIs are provided for source systems which have an acknowledgement
mechanism for messages. Overriding these methods allows the source
connector to acknowledge messages in the source system, either in bulk
or individually, once they have been written to Kafka. The <code class="docutils literal"><span class="pre">commit</span></code>
API stores the offsets in the source system, up to the offsets that have
been returned by <code class="docutils literal"><span class="pre">poll</span></code>. The implementation of this API should block
until the commit is complete. The <code class="docutils literal"><span class="pre">commitRecord</span></code> API saves the offset
in the source system for each <code class="docutils literal"><span class="pre">SourceRecord</span></code> after it is written to
Kafka. As Kafka Connect will record offsets automatically,
<code class="docutils literal"><span class="pre">SourceTask</span></code>s are not required to implement them. In cases where a
connector does need to acknowledge messages in the source system, only
one of the APIs is typically required.</p>
<p>Even with multiple tasks, this method implementation is usually pretty
simple. It just has to determine the number of input tasks, which may
require contacting the remote service it is pulling data from, and then
divvy them up. Because some patterns for splitting work among tasks are
so common, some utilities are provided in <code class="docutils literal"><span class="pre">ConnectorUtils</span></code> to simplify
these cases.</p>
<p>Note that this simple example does not include dynamic input. See the
discussion in the next section for how to trigger updates to task
configs.</p>
</div>
<div class="section" id="task-example-source-task">
<h4><a class="reference external" href="#connect_taskexample">Task Example - Source Task</a><a class="headerlink" href="#task-example-source-task" title="Permalink to this headline">¶</a></h4>
<p>Next we&#8217;ll describe the implementation of the corresponding
<code class="docutils literal"><span class="pre">SourceTask</span></code>. The implementation is short, but too long to cover
completely in this guide. We&#8217;ll use pseudo-code to describe most of the
implementation, but you can refer to the source code for the full
example.</p>
<p>Just as with the connector, we need to create a class inheriting from
the appropriate base <code class="docutils literal"><span class="pre">Task</span></code> class. It also has some standard lifecycle
methods:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">FileStreamSourceTask</span> <span class="n">extends</span> <span class="n">SourceTask</span> <span class="p">{</span>
    <span class="n">String</span> <span class="n">filename</span><span class="p">;</span>
    <span class="n">InputStream</span> <span class="n">stream</span><span class="p">;</span>
    <span class="n">String</span> <span class="n">topic</span><span class="p">;</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">start</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">FileStreamSourceConnector</span><span class="o">.</span><span class="n">FILE_CONFIG</span><span class="p">);</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">openOrThrowError</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
        <span class="n">topic</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">FileStreamSourceConnector</span><span class="o">.</span><span class="n">TOPIC_CONFIG</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">synchronized</span> <span class="n">void</span> <span class="n">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>These are slightly simplified versions, but show that these methods
should be relatively simple and the only work they should perform is
allocating or freeing resources. There are two points to note about this
implementation. First, the <code class="docutils literal"><span class="pre">start()</span></code> method does not yet handle
resuming from a previous offset, which will be addressed in a later
section. Second, the <code class="docutils literal"><span class="pre">stop()</span></code> method is synchronized. This will be
necessary because <code class="docutils literal"><span class="pre">SourceTasks</span></code> are given a dedicated thread which
they can block indefinitely, so they need to be stopped with a call from
a different thread in the Worker.</p>
<p>Next, we implement the main functionality of the task, the <code class="docutils literal"><span class="pre">poll()</span></code>
method which gets events from the input system and returns a
<code class="docutils literal"><span class="pre">List&lt;SourceRecord&gt;</span></code>:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="nd">@Override</span>
<span class="n">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">SourceRecord</span><span class="o">&gt;</span> <span class="n">poll</span><span class="p">()</span> <span class="n">throws</span> <span class="n">InterruptedException</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">SourceRecord</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">streamValid</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">records</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">LineAndOffset</span> <span class="n">line</span> <span class="o">=</span> <span class="n">readToNextLine</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">line</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">sourcePartition</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="n">singletonMap</span><span class="p">(</span><span class="s2">&quot;filename&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
                <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">sourceOffset</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="n">singletonMap</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="n">streamOffset</span><span class="p">);</span>
                <span class="n">records</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new</span> <span class="n">SourceRecord</span><span class="p">(</span><span class="n">sourcePartition</span><span class="p">,</span> <span class="n">sourceOffset</span><span class="p">,</span> <span class="n">topic</span><span class="p">,</span> <span class="n">Schema</span><span class="o">.</span><span class="n">STRING_SCHEMA</span><span class="p">,</span> <span class="n">line</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">records</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">Underlying</span> <span class="n">stream</span> <span class="n">was</span> <span class="n">killed</span><span class="p">,</span> <span class="n">probably</span> <span class="k">as</span> <span class="n">a</span> <span class="n">result</span> <span class="n">of</span> <span class="n">calling</span> <span class="n">stop</span><span class="o">.</span> <span class="n">Allow</span> <span class="n">to</span> <span class="k">return</span>
        <span class="o">//</span> <span class="n">null</span><span class="p">,</span> <span class="ow">and</span> <span class="n">driving</span> <span class="n">thread</span> <span class="n">will</span> <span class="n">handle</span> <span class="nb">any</span> <span class="n">shutdown</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Again, we&#8217;ve omitted some details, but we can see the important steps:
the <code class="docutils literal"><span class="pre">poll()</span></code> method is going to be called repeatedly, and for each
call it will loop trying to read records from the file. For each line it
reads, it also tracks the file offset. It uses this information to
create an output <code class="docutils literal"><span class="pre">SourceRecord</span></code> with four pieces of information: the
source partition (there is only one, the single file being read), source
offset (byte offset in the file), output topic name, and output value
(the line, and we include a schema indicating this value will always be
a string). Other variants of the <code class="docutils literal"><span class="pre">SourceRecord</span></code> constructor can also
include a specific output partition, a key, and headers.</p>
<p>Note that this implementation uses the normal Java <code class="docutils literal"><span class="pre">InputStream</span></code>
interface and may sleep if data is not available. This is acceptable
because Kafka Connect provides each task with a dedicated thread. While
task implementations have to conform to the basic <code class="docutils literal"><span class="pre">poll()</span></code> interface,
they have a lot of flexibility in how they are implemented. In this
case, an NIO-based implementation would be more efficient, but this
simple approach works, is quick to implement, and is compatible with
older versions of Java.</p>
</div>
<div class="section" id="sink-tasks">
<h4><a class="reference external" href="#connect_sinktasks">Sink Tasks</a><a class="headerlink" href="#sink-tasks" title="Permalink to this headline">¶</a></h4>
<p>The previous section described how to implement a simple <code class="docutils literal"><span class="pre">SourceTask</span></code>.
Unlike <code class="docutils literal"><span class="pre">SourceConnector</span></code> and <code class="docutils literal"><span class="pre">SinkConnector</span></code>, <code class="docutils literal"><span class="pre">SourceTask</span></code> and
<code class="docutils literal"><span class="pre">SinkTask</span></code> have very different interfaces because <code class="docutils literal"><span class="pre">SourceTask</span></code> uses
a pull interface and <code class="docutils literal"><span class="pre">SinkTask</span></code> uses a push interface. Both share the
common lifecycle methods, but the <code class="docutils literal"><span class="pre">SinkTask</span></code> interface is quite
different:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">abstract</span> <span class="k">class</span> <span class="nc">SinkTask</span> <span class="n">implements</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">initialize</span><span class="p">(</span><span class="n">SinkTaskContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">abstract</span> <span class="n">void</span> <span class="n">put</span><span class="p">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">SinkRecord</span><span class="o">&gt;</span> <span class="n">records</span><span class="p">);</span>

    <span class="n">public</span> <span class="n">void</span> <span class="n">flush</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="p">,</span> <span class="n">OffsetAndMetadata</span><span class="o">&gt;</span> <span class="n">currentOffsets</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">SinkTask</span></code> documentation contains full details, but this interface
is nearly as simple as the <code class="docutils literal"><span class="pre">SourceTask</span></code>. The <code class="docutils literal"><span class="pre">put()</span></code> method should
contain most of the implementation, accepting sets of <code class="docutils literal"><span class="pre">SinkRecords</span></code>,
performing any required translation, and storing them in the destination
system. This method does not need to ensure the data has been fully
written to the destination system before returning. In fact, in many
cases internal buffering will be useful so an entire batch of records
can be sent at once, reducing the overhead of inserting events into the
downstream data store. The <code class="docutils literal"><span class="pre">SinkRecords</span></code> contain essentially the same
information as <code class="docutils literal"><span class="pre">SourceRecords</span></code>: Kafka topic, partition, offset, the
event key and value, and optional headers.</p>
<p>The <code class="docutils literal"><span class="pre">flush()</span></code> method is used during the offset commit process, which
allows tasks to recover from failures and resume from a safe point such
that no events will be missed. The method should push any outstanding
data to the destination system and then block until the write has been
acknowledged. The <code class="docutils literal"><span class="pre">offsets</span></code> parameter can often be ignored, but is
useful in some cases where implementations want to store offset
information in the destination store to provide exactly-once delivery.
For example, an HDFS connector could do this and use atomic move
operations to make sure the <code class="docutils literal"><span class="pre">flush()</span></code> operation atomically commits the
data and offsets to a final location in HDFS.</p>
</div>
<div class="section" id="resuming-from-previous-offsets">
<h4><a class="reference external" href="#connect_resuming">Resuming from Previous Offsets</a><a class="headerlink" href="#resuming-from-previous-offsets" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">SourceTask</span></code> implementation included a stream ID (the input
filename) and offset (position in the file) with each record. The
framework uses this to commit offsets periodically so that in the case
of a failure, the task can recover and minimize the number of events
that are reprocessed and possibly duplicated (or to resume from the most
recent offset if Kafka Connect was stopped gracefully, e.g. in
standalone mode or due to a job reconfiguration). This commit process is
completely automated by the framework, but only the connector knows how
to seek back to the right position in the input stream to resume from
that location.</p>
<p>To correctly resume upon startup, the task can use the <code class="docutils literal"><span class="pre">SourceContext</span></code>
passed into its <code class="docutils literal"><span class="pre">initialize()</span></code> method to access the offset data. In
<code class="docutils literal"><span class="pre">initialize()</span></code>, we would add a bit more code to read the offset (if it
exists) and seek to that position:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">stream</span> <span class="o">=</span> <span class="n">new</span> <span class="n">FileInputStream</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">offsetStorageReader</span><span class="p">()</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">Collections</span><span class="o">.</span><span class="n">singletonMap</span><span class="p">(</span><span class="n">FILENAME_FIELD</span><span class="p">,</span> <span class="n">filename</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Long</span> <span class="n">lastRecordedOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Long</span><span class="p">)</span> <span class="n">offset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lastRecordedOffset</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
        <span class="n">seekToOffset</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">lastRecordedOffset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Of course, you might need to read many keys for each of the input
streams. The <code class="docutils literal"><span class="pre">OffsetStorageReader</span></code> interface also allows you to issue
bulk reads to efficiently load all offsets, then apply them by seeking
each input stream to the appropriate position.</p>
</div>
</div>
<div class="section" id="dynamic-input-output-streams">
<h3><a class="reference external" href="#connect_dynamicio">Dynamic Input/Output Streams</a><a class="headerlink" href="#dynamic-input-output-streams" title="Permalink to this headline">¶</a></h3>
<p>Kafka Connect is intended to define bulk data copying jobs, such as
copying an entire database rather than creating many jobs to copy each
table individually. One consequence of this design is that the set of
input or output streams for a connector can vary over time.</p>
<p>Source connectors need to monitor the source system for changes, e.g.
table additions/deletions in a database. When they pick up changes, they
should notify the framework via the <code class="docutils literal"><span class="pre">ConnectorContext</span></code> object that
reconfiguration is necessary. For example, in a <code class="docutils literal"><span class="pre">SourceConnector</span></code>:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">inputsChanged</span><span class="p">())</span>
    <span class="n">this</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">requestTaskReconfiguration</span><span class="p">();</span>
</pre></div>
</div>
<p>The framework will promptly request new configuration information and
update the tasks, allowing them to gracefully commit their progress
before reconfiguring them. Note that in the <code class="docutils literal"><span class="pre">SourceConnector</span></code> this
monitoring is currently left up to the connector implementation. If an
extra thread is required to perform this monitoring, the connector must
allocate it itself.</p>
<p>Ideally this code for monitoring changes would be isolated to the
<code class="docutils literal"><span class="pre">Connector</span></code> and tasks would not need to worry about them. However,
changes can also affect tasks, most commonly when one of their input
streams is destroyed in the input system, e.g. if a table is dropped
from a database. If the <code class="docutils literal"><span class="pre">Task</span></code> encounters the issue before the
<code class="docutils literal"><span class="pre">Connector</span></code>, which will be common if the <code class="docutils literal"><span class="pre">Connector</span></code> needs to poll
for changes, the <code class="docutils literal"><span class="pre">Task</span></code> will need to handle the subsequent error.
Thankfully, this can usually be handled simply by catching and handling
the appropriate exception.</p>
<p><code class="docutils literal"><span class="pre">SinkConnectors</span></code> usually only have to handle the addition of streams,
which may translate to new entries in their outputs (e.g., a new
database table). The framework manages any changes to the Kafka input,
such as when the set of input topics changes because of a regex
subscription. <code class="docutils literal"><span class="pre">SinkTasks</span></code> should expect new input streams, which may
require creating new resources in the downstream system, such as a new
table in a database. The trickiest situation to handle in these cases
may be conflicts between multiple <code class="docutils literal"><span class="pre">SinkTasks</span></code> seeing a new input
stream for the first time and simultaneously trying to create the new
resource. <code class="docutils literal"><span class="pre">SinkConnectors</span></code>, on the other hand, will generally require
no special code for handling a dynamic set of streams.</p>
</div>
<div class="section" id="connect-configuration-validation">
<h3><a class="reference external" href="#connect_configs">Connect Configuration Validation</a><a class="headerlink" href="#connect-configuration-validation" title="Permalink to this headline">¶</a></h3>
<p>Kafka Connect allows you to validate connector configurations before
submitting a connector to be executed and can provide feedback about
errors and recommended values. To take advantage of this, connector
developers need to provide an implementation of <code class="docutils literal"><span class="pre">config()</span></code> to expose
the configuration definition to the framework.</p>
<p>The following code in <code class="docutils literal"><span class="pre">FileStreamSourceConnector</span></code> defines the
configuration and exposes it to the framework.</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">final</span> <span class="n">ConfigDef</span> <span class="n">CONFIG_DEF</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ConfigDef</span><span class="p">()</span>
    <span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">FILE_CONFIG</span><span class="p">,</span> <span class="n">Type</span><span class="o">.</span><span class="n">STRING</span><span class="p">,</span> <span class="n">Importance</span><span class="o">.</span><span class="n">HIGH</span><span class="p">,</span> <span class="s2">&quot;Source filename.&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">TOPIC_CONFIG</span><span class="p">,</span> <span class="n">Type</span><span class="o">.</span><span class="n">STRING</span><span class="p">,</span> <span class="n">Importance</span><span class="o">.</span><span class="n">HIGH</span><span class="p">,</span> <span class="s2">&quot;The topic to publish data to&quot;</span><span class="p">);</span>

<span class="n">public</span> <span class="n">ConfigDef</span> <span class="n">config</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">CONFIG_DEF</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ConfigDef</span></code> class is used for specifying the set of expected
configurations. For each configuration, you can specify the name, the
type, the default value, the documentation, the group information, the
order in the group, the width of the configuration value and the name
suitable for display in the UI. Plus, you can provide special validation
logic used for single configuration validation by overriding the
<code class="docutils literal"><span class="pre">Validator</span></code> class. Moreover, as there may be dependencies between
configurations, for example, the valid values and visibility of a
configuration may change according to the values of other
configurations. To handle this, <code class="docutils literal"><span class="pre">ConfigDef</span></code> allows you to specify the
dependents of a configuration and to provide an implementation of
<code class="docutils literal"><span class="pre">Recommender</span></code> to get valid values and set visibility of a
configuration given the current configuration values.</p>
<p>Also, the <code class="docutils literal"><span class="pre">validate()</span></code> method in <code class="docutils literal"><span class="pre">Connector</span></code> provides a default
validation implementation which returns a list of allowed configurations
together with configuration errors and recommended values for each
configuration. However, it does not use the recommended values for
configuration validation. You may provide an override of the default
implementation for customized configuration validation, which may use
the recommended values.</p>
</div>
<div class="section" id="working-with-schemas">
<h3><a class="reference external" href="#connect_schemas">Working with Schemas</a><a class="headerlink" href="#working-with-schemas" title="Permalink to this headline">¶</a></h3>
<p>The FileStream connectors are good examples because they are simple, but
they also have trivially structured data &#8211; each line is just a string.
Almost all practical connectors will need schemas with more complex data
formats.</p>
<p>To create more complex data, you&#8217;ll need to work with the Kafka Connect
<code class="docutils literal"><span class="pre">data</span></code> API. Most structured records will need to interact with two
classes in addition to primitive types: <code class="docutils literal"><span class="pre">Schema</span></code> and <code class="docutils literal"><span class="pre">Struct</span></code>.</p>
<p>The API documentation provides a complete reference, but here is a
simple example creating a <code class="docutils literal"><span class="pre">Schema</span></code> and <code class="docutils literal"><span class="pre">Struct</span></code>:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">Schema</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">SchemaBuilder</span><span class="o">.</span><span class="n">struct</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="n">NAME</span><span class="p">)</span>
    <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">Schema</span><span class="o">.</span><span class="n">STRING_SCHEMA</span><span class="p">)</span>
    <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">,</span> <span class="n">Schema</span><span class="o">.</span><span class="n">INT_SCHEMA</span><span class="p">)</span>
    <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;admin&quot;</span><span class="p">,</span> <span class="n">new</span> <span class="n">SchemaBuilder</span><span class="o">.</span><span class="n">boolean</span><span class="p">()</span><span class="o">.</span><span class="n">defaultValue</span><span class="p">(</span><span class="n">false</span><span class="p">)</span><span class="o">.</span><span class="n">build</span><span class="p">())</span>
    <span class="o">.</span><span class="n">build</span><span class="p">();</span>

<span class="n">Struct</span> <span class="n">struct</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Struct</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;Barbara Liskov&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">,</span> <span class="mi">75</span><span class="p">);</span>
</pre></div>
</div>
<p>If you are implementing a source connector, you&#8217;ll need to decide when
and how to create schemas. Where possible, you should avoid recomputing
them as much as possible. For example, if your connector is guaranteed
to have a fixed schema, create it statically and reuse a single
instance.</p>
<p>However, many connectors will have dynamic schemas. One simple example
of this is a database connector. Considering even just a single table,
the schema will not be predefined for the entire connector (as it varies
from table to table). But it also may not be fixed for a single table
over the lifetime of the connector since the user may execute an
<code class="docutils literal"><span class="pre">ALTER</span> <span class="pre">TABLE</span></code> command. The connector must be able to detect these
changes and react appropriately.</p>
<p>Sink connectors are usually simpler because they are consuming data and
therefore do not need to create schemas. However, they should take just
as much care to validate that the schemas they receive have the expected
format. When the schema does not match &#8211; usually indicating the
upstream producer is generating invalid data that cannot be correctly
translated to the destination system &#8211; sink connectors should throw an
exception to indicate this error to the system.</p>
</div>
<div class="section" id="kafka-connect-administration">
<h3><a class="reference external" href="#connect_administration">Kafka Connect Administration</a><a class="headerlink" href="#kafka-connect-administration" title="Permalink to this headline">¶</a></h3>
<p>Kafka Connect&#8217;s <a class="reference external" href="#connect_rest">REST layer</a> provides a set of APIs to
enable administration of the cluster. This includes APIs to view the
configuration of connectors and the status of their tasks, as well as to
alter their current behavior (e.g. changing configuration and restarting
tasks).</p>
<p>When a connector is first submitted to the cluster, the workers
rebalance the full set of connectors in the cluster and their tasks so
that each worker has approximately the same amount of work. This same
rebalancing procedure is also used when connectors increase or decrease
the number of tasks they require, or when a connector&#8217;s configuration is
changed. You can use the REST API to view the current status of a
connector and its tasks, including the id of the worker to which each
was assigned. For example, querying the status of a file source (using
<code class="docutils literal"><span class="pre">GET</span> <span class="pre">/connectors/file-source/status</span></code>) might produce output like the
following:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;file-source&quot;</span><span class="p">,</span>
<span class="s2">&quot;connector&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="s2">&quot;RUNNING&quot;</span><span class="p">,</span>
    <span class="s2">&quot;worker_id&quot;</span><span class="p">:</span> <span class="s2">&quot;192.168.1.208:8083&quot;</span>
<span class="p">},</span>
<span class="s2">&quot;tasks&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="s2">&quot;RUNNING&quot;</span><span class="p">,</span>
    <span class="s2">&quot;worker_id&quot;</span><span class="p">:</span> <span class="s2">&quot;192.168.1.209:8083&quot;</span>
    <span class="p">}</span>
<span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Connectors and their tasks publish status updates to a shared topic
(configured with <code class="docutils literal"><span class="pre">status.storage.topic</span></code>) which all workers in the
cluster monitor. Because the workers consume this topic asynchronously,
there is typically a (short) delay before a state change is visible
through the status API. The following states are possible for a
connector or one of its tasks:</p>
<ul class="simple">
<li><strong>UNASSIGNED:</strong> The connector/task has not yet been assigned to a
worker.</li>
<li><strong>RUNNING:</strong> The connector/task is running.</li>
<li><strong>PAUSED:</strong> The connector/task has been administratively paused.</li>
<li><strong>FAILED:</strong> The connector/task has failed (usually by raising an
exception, which is reported in the status output).</li>
</ul>
<p>In most cases, connector and task states will match, though they may be
different for short periods of time when changes are occurring or if
tasks have failed. For example, when a connector is first started, there
may be a noticeable delay before the connector and its tasks have all
transitioned to the RUNNING state. States will also diverge when tasks
fail since Connect does not automatically restart failed tasks. To
restart a connector/task manually, you can use the restart APIs listed
above. Note that if you try to restart a task while a rebalance is
taking place, Connect will return a 409 (Conflict) status code. You can
retry after the rebalance completes, but it might not be necessary since
rebalances effectively restart all the connectors and tasks in the
cluster.</p>
<p>It&#8217;s sometimes useful to temporarily stop the message processing of a
connector. For example, if the remote system is undergoing maintenance,
it would be preferable for source connectors to stop polling it for new
data instead of filling logs with exception spam. For this use case,
Connect offers a pause/resume API. While a source connector is paused,
Connect will stop polling it for additional records. While a sink
connector is paused, Connect will stop pushing new messages to it. The
pause state is persistent, so even if you restart the cluster, the
connector will not begin message processing again until the task has
been resumed. Note that there may be a delay before all of a connector&#8217;s
tasks have transitioned to the PAUSED state since it may take time for
them to finish whatever processing they were in the middle of when being
paused. Additionally, failed tasks will not transition to the PAUSED
state until they have been restarted.</p>
<div class="p-connect"></div></div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="security.html" class="btn btn-neutral" title="Security" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Apache Software Foundation.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>