

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Core Concepts &mdash; Apache Kafka 4.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Apache Kafka 4.0.0 documentation" href="../../index.html"/>
        <link rel="up" title="Kafka Streams" href="index.html"/>
        <link rel="next" title="Architecture" href="architecture.html"/>
        <link rel="prev" title="Tutorial: Write a Kafka Streams Application" href="tutorial.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Apache Kafka
          

          
          </a>

          
            
            
              <div class="version">
                4.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../uses.html">Use Cases</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Apache Kafka Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html">Kafka APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../configuration.html">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../design.html">Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../implementation.html">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ops.html">Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security.html">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connect.html">Kafka Connect</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Kafka Streams</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="quickstart.html">Run Kafka Streams Demo Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="tutorial.html">Tutorial: Write a Kafka Streams Application</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Core Concepts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stream-processing-topology">Stream Processing Topology</a></li>
<li class="toctree-l4"><a class="reference internal" href="#time">Time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#states">States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#processing-guarantees">Processing Guarantees</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="architecture.html">Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="developer-guide/index.html">Developer Guide for Kafka Streams</a></li>
<li class="toctree-l3"><a class="reference internal" href="upgrade-guide.html">Upgrade Guide and API Changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#why-you-ll-love-using-kafka-streams">Why you&#8217;ll love using Kafka Streams!</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#kafka-streams-use-cases">Kafka Streams use cases</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#hello-kafka-streams">Hello Kafka Streams</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Apache Kafka</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Apache Kafka Documentation</a> &raquo;</li>
        
          <li><a href="index.html">Kafka Streams</a> &raquo;</li>
        
      <li>Core Concepts</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/documentation/streams/core-concepts.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-concepts">
<span id="streams-concepts"></span><h1>Core Concepts<a class="headerlink" href="#core-concepts" title="Permalink to this headline">¶</a></h1>
<p>Kafka Streams is a client library for processing and analyzing data
stored in Kafka. It builds upon important stream processing concepts
such as properly distinguishing between event time and processing time,
windowing support, and simple yet efficient management and real-time
querying of application state.</p>
<p>Kafka Streams has a <strong>low barrier to entry</strong>: You can quickly write and
run a small-scale proof-of-concept on a single machine; and you only
need to run additional instances of your application on multiple
machines to scale up to high-volume production workloads. Kafka Streams
transparently handles the load balancing of multiple instances of the
same application by leveraging Kafka&#8217;s parallelism model.</p>
<p>Some highlights of Kafka Streams:</p>
<ul class="simple">
<li>Designed as a <strong>simple and lightweight client library</strong>, which can be
easily embedded in any Java application and integrated with any
existing packaging, deployment and operational tools that users have
for their streaming applications.</li>
<li>Has <strong>no external dependencies on systems other than Apache Kafka
itself</strong> as the internal messaging layer; notably, it uses Kafka&#8217;s
partitioning model to horizontally scale processing while maintaining
strong ordering guarantees.</li>
<li>Supports <strong>fault-tolerant local state</strong>, which enables very fast and
efficient stateful operations like windowed joins and aggregations.</li>
<li>Supports <strong>exactly-once</strong> processing semantics to guarantee that each
record will be processed once and only once even when there is a
failure on either Streams clients or Kafka brokers in the middle of
processing.</li>
<li>Employs <strong>one-record-at-a-time processing</strong> to achieve millisecond
processing latency, and supports <strong>event-time based windowing
operations</strong> with late arrival of records.</li>
<li>Offers necessary stream processing primitives, along with a
<strong>high-level Streams DSL</strong> and a <strong>low-level Processor API</strong>.</li>
</ul>
<p>We first summarize the key concepts of Kafka Streams.</p>
<div class="section" id="stream-processing-topology">
<h2><a class="reference external" href="#streams_topology">Stream Processing Topology</a><a class="headerlink" href="#stream-processing-topology" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>A <strong>stream</strong> is the most important abstraction provided by Kafka
Streams: it represents an unbounded, continuously updating data set.
A stream is an ordered, replayable, and fault-tolerant sequence of
immutable data records, where a <strong>data record</strong> is defined as a
key-value pair.</li>
<li>A <strong>stream processing application</strong> is any program that makes use of
the Kafka Streams library. It defines its computational logic through
one or more <strong>processor topologies</strong>, where a processor topology is a
graph of stream processors (nodes) that are connected by streams
(edges).</li>
<li>A <strong>stream processor</strong> is a node in the processor topology; it
represents a processing step to transform data in streams by
receiving one input record at a time from its upstream processors in
the topology, applying its operation to it, and may subsequently
produce one or more output records to its downstream processors.</li>
</ul>
<p>There are two special processors in the topology:</p>
<ul class="simple">
<li><strong>Source Processor</strong>: A source processor is a special type of stream
processor that does not have any upstream processors. It produces an
input stream to its topology from one or multiple Kafka topics by
consuming records from these topics and forwarding them to its
down-stream processors.</li>
<li><strong>Sink Processor</strong>: A sink processor is a special type of stream
processor that does not have down-stream processors. It sends any
received records from its up-stream processors to a specified Kafka
topic.</li>
</ul>
<p>Note that in normal processor nodes other remote systems can also be
accessed while processing the current record. Therefore the processed
results can either be streamed back into Kafka or written to an external
system.</p>
<a class="reference internal image-reference" href="../../_images/streams-architecture-topology.jpg"><img alt="../../_images/streams-architecture-topology.jpg" class="align-center" src="../../_images/streams-architecture-topology.jpg" style="width: 400px;" /></a>
<p>Kafka Streams offers two ways to define the stream processing topology:
the <a class="reference external" href="/%7B%7Bversion%7D%7D/documentation/streams/developer-guide#streams_dsl">Kafka Streams
DSL</a>
provides the most common data transformation operations such as <code class="docutils literal"><span class="pre">map</span></code>,
<code class="docutils literal"><span class="pre">filter</span></code>, <code class="docutils literal"><span class="pre">join</span></code> and <code class="docutils literal"><span class="pre">aggregations</span></code> out of the box; the
lower-level <a class="reference external" href="/%7B%7Bversion%7D%7D/documentation/streams/developer-guide#streams_processor">Processor
API</a>
allows developers define and connect custom processors as well as to
interact with <a class="reference external" href="#streams_state">state stores</a>.</p>
<p>A processor topology is merely a logical abstraction for your stream
processing code. At runtime, the logical topology is instantiated and
replicated inside the application for parallel processing (see <a class="reference external" href="#streams_architecture_tasks">Stream
Partitions and Tasks</a> for details).</p>
</div>
<div class="section" id="time">
<h2><a class="reference external" href="#streams_time">Time</a><a class="headerlink" href="#time" title="Permalink to this headline">¶</a></h2>
<p>A critical aspect in stream processing is the notion of <strong>time</strong>, and
how it is modeled and integrated. For example, some operations such as
<strong>windowing</strong> are defined based on time boundaries.</p>
<p>Common notions of time in streams are:</p>
<ul class="simple">
<li><strong>Event time</strong> - The point in time when an event or data record
occurred, i.e. was originally created &#8220;at the source&#8221;. <strong>Example:</strong>
If the event is a geo-location change reported by a GPS sensor in a
car, then the associated event-time would be the time when the GPS
sensor captured the location change.</li>
<li><strong>Processing time</strong> - The point in time when the event or data record
happens to be processed by the stream processing application, i.e.
when the record is being consumed. The processing time may be
milliseconds, hours, or days etc. later than the original event time.
<strong>Example:</strong> Imagine an analytics application that reads and
processes the geo-location data reported from car sensors to present
it to a fleet management dashboard. Here, processing-time in the
analytics application might be milliseconds or seconds (e.g. for
real-time pipelines based on Apache Kafka and Kafka Streams) or hours
(e.g. for batch pipelines based on Apache Hadoop or Apache Spark)
after event-time.</li>
<li><strong>Ingestion time</strong> - The point in time when an event or data record
is stored in a topic partition by a Kafka broker. The difference to
event time is that this ingestion timestamp is generated when the
record is appended to the target topic by the Kafka broker, not when
the record is created &#8220;at the source&#8221;. The difference to processing
time is that processing time is when the stream processing
application processes the record. <strong>For example,</strong> if a record is
never processed, there is no notion of processing time for it, but it
still has an ingestion time.</li>
</ul>
<p>The choice between event-time and ingestion-time is actually done
through the configuration of Kafka (not Kafka Streams): From Kafka
0.10.x onwards, timestamps are automatically embedded into Kafka
messages. Depending on Kafka&#8217;s configuration these timestamps represent
event-time or ingestion-time. The respective Kafka configuration setting
can be specified on the broker level or per topic. The default timestamp
extractor in Kafka Streams will retrieve these embedded timestamps
as-is. Hence, the effective time semantics of your application depend on
the effective Kafka configuration for these embedded timestamps.</p>
<p>Kafka Streams assigns a <strong>timestamp</strong> to every data record via the
<code class="docutils literal"><span class="pre">TimestampExtractor</span></code> interface. These per-record timestamps describe
the progress of a stream with regards to time and are leveraged by
time-dependent operations such as window operations. As a result, this
time will only advance when a new record arrives at the processor. We
call this data-driven time the <strong>stream time</strong> of the application to
differentiate with the <strong>wall-clock time</strong> when this application is
actually executing. Concrete implementations of the
<code class="docutils literal"><span class="pre">TimestampExtractor</span></code> interface will then provide different semantics
to the stream time definition. For example retrieving or computing
timestamps based on the actual contents of data records such as an
embedded timestamp field to provide event time semantics, and returning
the current wall-clock time thereby yield processing time semantics to
stream time. Developers can thus enforce different notions of time
depending on their business needs.</p>
<p>Finally, whenever a Kafka Streams application writes records to Kafka,
then it will also assign timestamps to these new records. The way the
timestamps are assigned depends on the context:</p>
<ul class="simple">
<li>When new output records are generated via processing some input
record, for example, <code class="docutils literal"><span class="pre">context.forward()</span></code> triggered in the
<code class="docutils literal"><span class="pre">process()</span></code> function call, output record timestamps are inherited
from input record timestamps directly.</li>
<li>When new output records are generated via periodic functions such as
<code class="docutils literal"><span class="pre">Punctuator#punctuate()</span></code>, the output record timestamp is defined as
the current internal time (obtained through <code class="docutils literal"><span class="pre">context.timestamp()</span></code>)
of the stream task.</li>
<li>For aggregations, the timestamp of a resulting aggregate update
record will be that of the latest arrived input record that triggered
the update.</li>
</ul>
</div>
<div class="section" id="states">
<h2><a class="reference external" href="#streams_state">States</a><a class="headerlink" href="#states" title="Permalink to this headline">¶</a></h2>
<p>Some stream processing applications don&#8217;t require state, which means the
processing of a message is independent from the processing of all other
messages. However, being able to maintain state opens up many
possibilities for sophisticated stream processing applications: you can
join input streams, or group and aggregate data records. Many such
stateful operators are provided by the <a class="reference external" href="/%7B%7Bversion%7D%7D/documentation/streams/developer-guide#streams_dsl">Kafka Streams
DSL</a>.</p>
<p>Kafka Streams provides so-called <strong>state stores</strong>, which can be used by
stream processing applications to store and query data. This is an
important capability when implementing stateful operations. Every task
in Kafka Streams embeds one or more state stores that can be accessed
via APIs to store and query data required for processing. These state
stores can either be a persistent key-value store, an in-memory hashmap,
or another convenient data structure. Kafka Streams offers
fault-tolerance and automatic recovery for local state stores.</p>
<p>Kafka Streams allows direct read-only queries of the state stores by
methods, threads, processes or applications external to the stream
processing application that created the state stores. This is provided
through a feature called <strong>Interactive Queries</strong>. All stores are named
and Interactive Queries exposes only the read operations of the
underlying implementation.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="processing-guarantees">
<h2><a class="reference external" href="#streams_processing_guarantee">Processing Guarantees</a><a class="headerlink" href="#processing-guarantees" title="Permalink to this headline">¶</a></h2>
<p>In stream processing, one of the most frequently asked question is &#8220;does
my stream processing system guarantee that each record is processed once
and only once, even if some failures are encountered in the middle of
processing?&#8221; Failing to guarantee exactly-once stream processing is a
deal-breaker for many applications that cannot tolerate any data-loss or
data duplicates, and in that case a batch-oriented framework is usually
used in addition to the stream processing pipeline, known as the <a class="reference external" href="http://lambda-architecture.net/">Lambda
Architecture</a>. Prior to 0.11.0.0,
Kafka only provides at-least-once delivery guarantees and hence any
stream processing systems that leverage it as the backend storage could
not guarantee end-to-end exactly-once semantics. In fact, even for those
stream processing systems that claim to support exactly-once processing,
as long as they are reading from / writing to Kafka as the source /
sink, their applications cannot actually guarantee that no duplicates
will be generated throughout the pipeline. Since the 0.11.0.0 release,
Kafka has added support to allow its producers to send messages to
different topic partitions in a <a class="reference external" href="https://kafka.apache.org/documentation/#semantics">transactional and idempotent
manner</a>, and Kafka
Streams has hence added the end-to-end exactly-once processing semantics
by leveraging these features. More specifically, it guarantees that for
any record read from the source Kafka topics, its processing results
will be reflected exactly once in the output Kafka topic as well as in
the state stores for stateful operations. Note the key difference
between Kafka Streams end-to-end exactly-once guarantee with other
stream processing frameworks&#8217; claimed guarantees is that Kafka Streams
tightly integrates with the underlying Kafka storage system and ensure
that commits on the input topic offsets, updates on the state stores,
and writes to the output topics will be completed atomically instead of
treating Kafka as an external system that may have side-effects. To read
more details on how this is done inside Kafka Streams, readers are
recommended to read
<a class="reference external" href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-129%3A+Streams+Exactly-Once+Semantics">KIP-129</a>.
In order to achieve exactly-once semantics when running Kafka Streams
applications, users can simply set the <code class="docutils literal"><span class="pre">processing.guarantee</span></code> config
value to <strong>exactly_once</strong> (default value is <strong>at_least_once</strong>). More
details can be found in the <a class="reference external" href="/%7B%7Bversion%7D%7D/documentation#streamsconfigs">Kafka Streams
Configs</a>
section.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="architecture.html" class="btn btn-neutral float-right" title="Architecture" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tutorial.html" class="btn btn-neutral" title="Tutorial: Write a Kafka Streams Application" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Apache Software Foundation.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'4.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>