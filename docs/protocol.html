<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<!--#include virtual="../includes/_header.htm" -->
<!--#include virtual="../includes/_top.htm" -->
<div class="content">
    <!--#include virtual="../includes/_nav.htm" -->
    <div class="right">
        <h1>Kafka protocol guide</h1>

<p>This document covers the wire protocol implemented in Kafka. It is meant to give a readable guide to the protocol that covers the available requests, their binary format, and the proper way to make use of them to implement a client. This document assumes you understand the basic design and terminology described <a href="https://kafka.apache.org/documentation.html#design">here</a></p>

<ul class="toc">
    <li><a href="#protocol_preliminaries">Preliminaries</a>
        <ul>
            <li><a href="#protocol_network">Network</a>
            <li><a href="#protocol_partitioning">Partitioning and bootstrapping</a>
            <li><a href="#protocol_partitioning_strategies">Partitioning Strategies</a>
            <li><a href="#protocol_batching">Batching</a>
            <li><a href="#protocol_compatibility">Versioning and Compatibility</a>
        </ul>
    </li>
    <li><a href="#protocol_details">The Protocol</a>
        <ul>
            <li><a href="#protocol_types">Protocol Primitive Types</a>
            <li><a href="#protocol_grammar">Notes on reading the request format grammars</a>
            <li><a href="#protocol_common">Common Request and Response Structure</a>
            <li><a href="#protocol_message_sets">Message Sets</a>
        </ul>
    </li>
    <li><a href="#protocol_constants">Constants</a>
        <ul>
            <li><a href="#protocol_error_codes">Error Codes</a>
            <li><a href="#protocol_api_keys">Api Keys</a>
        </ul>
    </li>
    <li><a href="#protocol_messages">The Messages</a></li>
    <li><a href="#protocol_philosophy">Some Common Philosophical Questions</a></li>
</ul>

<h4><a id="protocol_preliminaries" href="#protocol_preliminaries">Preliminaries</a></h4>

<h5><a id="protocol_network" href="#protocol_network">Network</a></h5>

<p>Kafka uses a binary protocol over TCP. The protocol defines all apis as request response message pairs. All messages are size delimited and are made up of the following primitive types.</p>

<p>The client initiates a socket connection and then writes a sequence of request messages and reads back the corresponding response message. No handshake is required on connection or disconnection. TCP is happier if you maintain persistent connections used for many requests to amortize the cost of the TCP handshake, but beyond this penalty connecting is pretty cheap.</p>

<p>The client will likely need to maintain a connection to multiple brokers, as data is partitioned and the clients will need to talk to the server that has their data. However it should not generally be necessary to maintain multiple connections to a single broker from a single client instance (i.e. connection pooling).</p>

<p>The server guarantees that on a single TCP connection, requests will be processed in the order they are sent and responses will return in that order as well. The broker's request processing allows only a single in-flight request per connection in order to guarantee this ordering. Note that clients can (and ideally should) use non-blocking IO to implement request pipelining and achieve higher throughput. i.e., clients can send requests even while awaiting responses for preceding requests since the outstanding requests will be buffered in the underlying OS socket buffer. All requests are initiated by the client, and result in a corresponding response message from the server except where noted.</p>

<p>The server has a configurable maximum limit on request size and any request that exceeds this limit will result in the socket being disconnected.</p>

<h5><a id="protocol_partitioning" href="#protocol_partitioning">Partitioning and bootstrapping</a></h5>

<p>Kafka is a partitioned system so not all servers have the complete data set. Instead recall that topics are split into a pre-defined number of partitions, P, and each partition is replicated with some replication factor, N. Topic partitions themselves are just ordered "commit logs" numbered 0, 1, ..., P.</p>

<p>All systems of this nature have the question of how a particular piece of data is assigned to a particular partition. Kafka clients directly control this assignment, the brokers themselves enforce no particular semantics of which messages should be published to a particular partition. Rather, to publish messages the client directly addresses messages to a particular partition, and when fetching messages, fetches from a particular partition. If two clients want to use the same partitioning scheme they must use the same method to compute the mapping of key to partition.</p>

<p>These requests to publish or fetch data must be sent to the broker that is currently acting as the leader for a given partition. This condition is enforced by the broker, so a request for a particular partition to the wrong broker will result in an the NotLeaderForPartition error code (described below).</p>

<p>How can the client find out which topics exist, what partitions they have, and which brokers currently host those partitions so that it can direct its requests to the right hosts? This information is dynamic, so you can't just configure each client with some static mapping file. Instead all Kafka brokers can answer a metadata request that describes the current state of the cluster: what topics there are, which partitions those topics have, which broker is the leader for those partitions, and the host and port information for these brokers.</p>

<p>In other words, the client needs to somehow find one broker and that broker will tell the client about all the other brokers that exist and what partitions they host. This first broker may itself go down so the best practice for a client implementation is to take a list of two or three urls to bootstrap from. The user can then choose to use a load balancer or just statically configure two or three of their kafka hosts in the clients.</p>

<p>The client does not need to keep polling to see if the cluster has changed; it can fetch metadata once when it is instantiated cache that metadata until it receives an error indicating that the metadata is out of date. This error can come in two forms: (1) a socket error indicating the client cannot communicate with a particular broker, (2) an error code in the response to a request indicating that this broker no longer hosts the partition for which data was requested.</p>
<ol>
    <li>Cycle through a list of "bootstrap" kafka urls until we find one we can connect to. Fetch cluster metadata.</li>
    <li>Process fetch or produce requests, directing them to the appropriate broker based on the topic/partitions they send to or fetch from.</li>
    <li>If we get an appropriate error, refresh the metadata and try again.</li>
</ol>

<h5><a id="protocol_partitioning_strategies" href="#protocol_partitioning_strategies">Partitioning Strategies</a></h5>

<p>As mentioned above the assignment of messages to partitions is something the producing client controls. That said, how should this functionality be exposed to the end-user?</p>

<p>Partitioning really serves two purposes in Kafka:</p>
<ol>
    <li>It balances data and request load over brokers</li>
    <li>It serves as a way to divvy up processing among consumer processes while allowing local state and preserving order within the partition. We call this semantic partitioning.</li>
</ol>

<p>For a given use case you may care about only one of these or both.</p>

<p>To accomplish simple load balancing a simple approach would be for the client to just round robin requests over all brokers. Another alternative, in an environment where there are many more producers than brokers, would be to have each client chose a single partition at random and publish to that. This later strategy will result in far fewer TCP connections.</p>

<p>Semantic partitioning means using some key in the message to assign messages to partitions. For example if you were processing a click message stream you might want to partition the stream by the user id so that all data for a particular user would go to a single consumer. To accomplish this the client can take a key associated with the message and use some hash of this key to choose the partition to which to deliver the message.</p>

<h5><a id="protocol_batching" href="#protocol_batching">Batching</a></h5>

<p>Our apis encourage batching small things together for efficiency. We have found this is a very significant performance win. Both our API to send messages and our API to fetch messages always work with a sequence of messages not a single message to encourage this. A clever client can make use of this and support an "asynchronous" mode in which it batches together messages sent individually and sends them in larger clumps. We go even further with this and allow the batching across multiple topics and partitions, so a produce request may contain data to append to many partitions and a fetch request may pull data from many partitions all at once.</p>

<p>The client implementer can choose to ignore this and send everything one at a time if they like.</p>

<h5><a id="protocol_compatibility" href="#protocol_compatibility">Versioning and Compatibility</a></h5>

<p>The protocol is designed to enable incremental evolution in a backward compatible fashion. Our versioning is on a per API basis, each version consisting of a request and response pair. Each request contains an API key that identifies the API being invoked and a version number that indicates the format of the request and the expected format of the response.</p>

<p>The intention is that clients will support a range of API versions. When communicating with a particular broker, a given client should use the highest API version supported by both and indicate this version in their requests.</p>

<p>The server will reject requests with a version it does not support, and will always respond to the client with exactly the protocol format it expects based on the version it included in its request. The intended upgrade path is that new features would first be rolled out on the server (with the older clients not making use of them) and then as newer clients are deployed these new features would gradually be taken advantage of.</p>

<p>Our goal is primarily to allow API evolution in an environment where downtime is not allowed and clients and servers cannot all be changed at once.</p>

<p>Currently all versions are baselined at 0, as we evolve these APIs we will indicate the format for each version individually.</p>

<h5><a id="api_versions" href="#api_versions">Retrieving Supported API versions</a></h5>
<p>In order to work against multiple broker versions, clients need to know what versions of various APIs a
    broker supports. The broker exposes this information since 0.10.0.0 as described in <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-35+-+Retrieving+protocol+version">KIP-35</a>.
    Clients should use the supported API versions information to choose the highest API version supported by both client and broker. If no such version
    exists, an error should be reported to the user.</p>
<p>The following sequence may be used by a client to obtain supported API versions from a broker.</p>
<ol>
    <li>Client sends <code>ApiVersionsRequest</code> to a broker after connection has been established with the broker. If SSL is enabled,
        this happens after SSL connection has been established.</li>
    <li>On receiving <code>ApiVersionsRequest</code>, a broker returns its full list of supported ApiKeys and
        versions regardless of current authentication state (e.g., before SASL authentication on an SASL listener, do note that no
        Kafka protocol requests may take place on a SSL listener before the SSL handshake is finished). If this is considered to
        leak information about the broker version a workaround is to use SSL with client authentication which is performed at an
        earlier stage of the connection where the <code>ApiVersionRequest</code> is not available. Also, note that broker versions older
        than 0.10.0.0 do not support this API and will either ignore the request or close connection in response to the request.</li>
    <li>If multiple versions of an API are supported by broker and client, clients are recommended to use the latest version supported
        by the broker and itself.</li>
    <li>Deprecation of a protocol version is done by marking an API version as deprecated in the protocol documentation.</li>
    <li>Supported API versions obtained from a broker are only valid for the connection on which that information is obtained.
        In the event of disconnection, the client should obtain the information from the broker again, as the broker might have been
        upgraded/downgraded in the mean time.</li>
</ol>

<h5><a id="sasl_handshake" href="#sasl_handshake">SASL Authentication Sequence</a></h5>
<p>The following sequence is used for SASL authentication:
<ol>
  <li>Kafka <code>ApiVersionsRequest</code> may be sent by the client to obtain the version ranges of requests supported by the broker. This is optional.</li>
  <li>Kafka <code>SaslHandshakeRequest</code> containing the SASL mechanism for authentication is sent by the client. If the requested mechanism is not enabled
    in the server, the server responds with the list of supported mechanisms and closes the client connection. If the mechanism is enabled
    in the server, the server sends a successful response and continues with SASL authentication.
  <li>The actual SASL authentication is now performed. A series of SASL client and server tokens corresponding to the mechanism are sent as opaque
    packets. These packets contain a 32-bit size followed by the token as defined by the protocol for the SASL mechanism.
  <li>If authentication succeeds, subsequent packets are handled as Kafka API requests. Otherwise, the client connection is closed.
</ol>
<p>For interoperability with 0.9.0.x clients, the first packet received by the server is handled as a SASL/GSSAPI client token if it is not a valid
Kafka request. SASL/GSSAPI authentication is performed starting with this packet, skipping the first two steps above.</p>


<h4><a id="protocol_details" href="#protocol_details">The Protocol</a></h4>

<h5><a id="protocol_types" href="#protocol_types">Protocol Primitive Types</a></h5>

<p>The protocol is built out of the following primitive types.</p>

<p><b>Fixed Width Primitives</b><p>

<p>int8, int16, int32, int64 - Signed integers with the given precision (in bits) stored in big endian order.</p>

<p><b>Variable Length Primitives</b><p>

<p>varint, varlong - Signed integers following the variable-length zig-zag encoding from <a href="http://code.google.com/apis/protocolbuffers/docs/encoding.html"> Google Protocol Buffers</a>.</p>

<p>bytes, string - These types consist of a signed integer giving a length N followed by N bytes of content. A length of -1 indicates null. string uses an int16 for its size, and bytes uses an int32.</p>

<p>data - raw byte sequence. When this type is used, the preceding field of the structure specifies its length.

<p><b>Arrays</b><p>

<p>This is a notation for handling repeated structures. These will always be encoded as an int32 size containing the length N followed by N repetitions of the structure which can itself be made up of other primitive types. In the BNF grammars below we will show an array of a structure foo as [foo].</p>

<h5><a id="protocol_grammar" href="#protocol_grammar">Notes on reading the request format grammars</a></h5>

<p>The <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a>s below give an exact context free grammar for the request and response binary format. The BNF is intentionally not compact in order to give human-readable name. As always in a BNF a sequence of productions indicates concatenation. When there are multiple possible productions these are separated with '|' and may be enclosed in parenthesis for grouping. The top-level definition is always given first and subsequent sub-parts are indented.</p>

<h5><a id="protocol_common" href="#protocol_common">Common Request and Response Structure</a></h5>

<p>All requests and responses originate from the following grammar which will be incrementally describe through the rest of this document:</p>

<pre>
RequestOrResponse => message_size (RequestMessage | ResponseMessage)
  message_size => INT32
</pre>

<table class="data-table"><tbody>
<tr><th>Field</th><th>Description</th></tr>
<tr><td>message_size</td><td>The message_size field gives the size of the subsequent request or response message in bytes. The client can read requests by first reading this 4 byte size as an integer N, and then reading and parsing the subsequent N bytes of the request.</td></tr>
</table>

<h5><a id="protocol_message_sets" href="#protocol_message_sets">Message Sets / Record Sets</a></h5>

<p>One structure common to both the produce and fetch requests is the message set format. A message in kafka is a key-value pair with a small amount of associated metadata. A message set is just a sequence of messages with offset and size information. This format happens to be used both for the on-disk storage on the broker and the on-the-wire format.</p>
<p>A message set is also the unit of compression in Kafka, and we allow messages to recursively contain compressed message sets to allow batch compression.</p>
<p> N.B., MessageSets are not preceded by an int32 like other array elements in the protocol.</p>

<b>Message Set:</b><br>
<p><pre>MessageSet (Version: 0) => [offset message_size message]
  offset => INT64
  message_size => INT32
  message => crc magic_byte attributes key value
    crc => INT32
    magic_byte => INT8
    attributes => INT8
    key => BYTES
    value => BYTES
</pre><table class="data-table"><tbody>
    <tr><th>Field</th>
        <th>Description</th>
    </tr><tr>
        <td>offset</td><td>This is the offset used in kafka as the log sequence number. When the producer is sending non compressed messages, it can set the offsets to anything. When the producer is sending compressed messages, to avoid server side recompression, each compressed message should have offset starting from 0 and increasing by one for each inner message in the compressed message. (see more details about compressed messages in Kafka below)</td></tr>
    <tr>
        <td>crc</td><td>The crc field contains the CRC32 of the remainder of the message bytes. This is used to check the integrity of the message on the broker and consumer.</td></tr>
    <tr>
        <td>magic_byte</td><td>This is a version id used to allow backwards compatible evolution of the message binary format. In this version the value is 0.</td></tr>
    <tr>
        <td>attributes</td><td><p>This byte holds metadata attributes about the message.</p><p>The lowest 3 bits contain the compression codec used for the message.</p><p>All other bits should be set to 0.</p></td></tr>
    <tr>
        <td>key</td><td>The key is an optional message key that was used for partition assignment. The key can be null.</td></tr>
    <tr>
        <td>value</td><td>The value is the actual message contents as an opaque byte array. Kafka supports recursive messages in which case this may itself contain a message set. The message can be null.</td></tr>
    </tbody></table>
 <p><pre>MessageSet (Version: 1) => [offset message_size message]
  offset => INT64
  message_size => INT32
  message => crc magic_byte attributes key value
    crc => INT32
    magic_byte => INT8
    attributes => INT8
    timestamp =>INT64
    key => BYTES
    value => BYTES
</pre><table class="data-table"><tbody>
    <tr><th>Field</th>
        <th>Description</th>
    </tr><tr>
        <td>offset</td><td>This is the offset used in kafka as the log sequence number. When the producer is sending non compressed messages, it can set the offsets to anything. When the producer is sending compressed messages, to avoid server side recompression, each compressed message should have offset starting from 0 and increasing by one for each inner message in the compressed message. (see more details about compressed messages in Kafka below)</td></tr>
    <tr>
        <td>crc</td><td>The crc field contains the CRC32 of the remainder of the message bytes. This is used to check the integrity of the message on the broker and consumer.</td></tr>
    <tr>
        <td>magic_byte</td><td>This is a version id used to allow backwards compatible evolution of the message binary format. In this version the value is 1.</td></tr>
    <tr>
        <td>attributes</td><td><p>This byte holds metadata attributes about the message.</p><p>The lowest 3 bits contain the compression codec used for the message.</p><p>The fourth lowest bit represents the timestamp type. 0 stands for CreateTime and 1 stands for LogAppendTime. The producer should always set this bit to 0.</p><p>All other bits should be set to 0.</p></td></tr>
    <tr>
        <td>timestamp</td><td>TThis is the timestamp of the message. The timestamp type is indicated in the attributes. Unit is milliseconds since beginning of the epoch (midnight Jan 1, 1970 (UTC)).</td></tr>
    <tr>
        <td>key</td><td>The key is an optional message key that was used for partition assignment. The key can be null.</td></tr>
    <tr>
        <td>value</td><td>The value is the actual message contents as an opaque byte array. Kafka supports recursive messages in which case this may itself contain a message set. The message can be null.</td></tr>
    </tbody></table>

<p>In Kafka 0.11, the structure of the 'MessageSet' and 'Message' were significantly changed. Not only were new fields added to support new features like exactly once semantics and record headers, but the recursive nature of the previous versions of the message format was eliminated in favor of a flat structure.
    A 'MessageSet' is now called a 'RecordBatch', which contains one or more 'Records' (and not 'Messages'). When compression is enabled, the RecordBatch header remains uncompressed, but the Records are compressed together. Further, multiple fields in the 'Record' are varint encoded, which leads to significant space savings for larger batches.</p>
<p>The new message format has a Magic value of 2. Its structure is as follows:</p>
<p><pre>RecordBatch (Version: 2) => first_offset recordbatch_length partition_leader_epoch magic_byte crc recordbatch_attributes last_offset_delta first_timestamp max_timestamp producer_id producer_epoch first_sequence records
  first_offset => INT64
  recordbatch_length => INT32
  partition_leader_epoch => INT32
  magic_byte => INT8
  crc => INT32
  recordbatch_attributes => INT16
  last_offset_delta => INT32
  first_timestamp => INT64
  max_timestamp => INT64
  producer_id => INT64
  producer_epoch => INT16
  first_sequence => INT32
  records => [record_length record_attributes timestamp_delta offset_delta key_length key value_length value headers]
    record_length => VARINT
    record_attributes => INT8
    timestamp_delta => VARLONG
    offset_delta => VARINT
    key_length => VARINT
    key => DATA
    value_length => VARINT
    value => DATA
    headers => [header_key_length header_key header_value_length header_value]
      header_key_length => VARINT
      header_key => STRING
      header_value_length => VARINT
      header_value => DATA

</pre><table class="data-table"><tbody>
    <tr><th>Field</th>
        <th>Description</th>
    </tr><tr>
        <td>first_offset</td><td>Denotes the first offset in the RecordBatch. The 'offset' of each Record in the batch would be be computed relative to this first_offset. In particular, the offset of each Record in the Batch is its 'offset_delta' + 'first_offset'.</td>
    </tr><tr>
        <td>recordbatch_length</td><td></td>
    </tr><tr>
        <td>partition_leader_epoch</td><td>Introduced with KIP-101, this is set by the broker upon receipt of a produce request and is used to ensure no loss of data when there are leader changes with log truncation. Client developers do not need to worry about setting this value.</td>
    </tr><tr>
        <td>magic_byte</td><td>This is a version id used to allow backwards compatible evolution of the message binary format. In this version the value is 2.</td>
    <tr>
        <td>crc</td><td>The crc field contains the CRC32 of the remainder of the message bytes. This is used to check the integrity of the message on the broker and consumer.</td>
    </tr><tr>
        <td>recordbatch_attributes</td><td><p>This byte holds metadata attributes about the message.</p>
        <p>The lowest 3 bits contain the compression codec used for the message.</p>
        <p>The fourth lowest bit represents the timestamp type. 0 stands for CreateTime and 1 stands for LogAppendTime. The producer should always set this bit to 0. (since 0.10.0)</p>
        <p>The fifth lowest bit indicates whether the RecordBatch is part of a transaction or not. 0 indicates that the RecordBatch is not transactional, while 1 indicates that it is. (since 0.11.0.0).</p>
        <p>The sixth lowest bit indicates whether the RecordBatch includes a control message. 1 indicates that the RecordBatch is contains a control message, 0 indicates that it doesn't. Control messages are used to enable transactions in Kafka and are generated by the broker. Clients should not return control batches (ie. those with this bit set) to applications. (since 0.11.0.0)</p></td>
    </tr><tr>
        <td>last_offset_delta</td><td>The offset of the last message in the RecordBatch. This is used by the broker to ensure correct behavior even when Records within a batch are compacted out.</td>
    </tr><tr>
        <td>first_timestamp</td><td>The timestamp of the first Record in the batch. The timestamp of each Record in the RecordBatch is its 'timestamp_delta' + 'first_timestamp'.</td>
    </tr><tr>
        <td>max_timestamp</td><td>The timestamp of the last Record in the batch. This is used by the broker to ensure the correct behavior even when Records within the batch are compacted out.</td>
    </tr><tr>
        <td>producer_id</td><td>Introduced in 0.11.0.0 for KIP-98, this is the broker assigned producerId received by the 'InitProducerId' request. Clients which want to support idempotent message delivery and transactions must set this field.</td>
    </tr><tr>
        <td>producer_epoch</td><td>Introduced in 0.11.0.0 for KIP-98, this is the broker assigned producerEpoch received by the 'InitProducerId' request. Clients which want to support idempotent message delivery and transactions must set this field.</td>
    </tr><tr>
        <td>first_sequence</td><td>Introduced in 0.11.0.0 for KIP-98, this is the producer assigned sequence number which is used by the broker to deduplicate messages. Clients which want to support idempotent message delivery and transactions must set this field. The sequence number for each Record in the RecordBatch is its 'offset_delta' + 'first_sequence'.</td>
    </tr><tr>
        <td>records</td><td>An array of Records. The number of elements is encoded as INT32.</td>
    </tr><tr>
        <td>record_length</td><td>The size of the record in bytes.</td>
    </tr><tr>
        <td>record_attributes</td><td>Record level attributes are presently unused.</td>
    </tr><tr>
        <td>timestamp_delta</td><td>The relative timestamp of the Record. The timestamp of each Record in the RecordBatch is its 'timestamp_delta' + 'first_timestamp'.</td>
    </tr><tr>
        <td>offset_delta</td><td>The relative offset of the Record. The 'offset' of each Record in the batch would be be computed as 'offset_delta' + 'first_offset'.</td>
    </tr><tr>
        <td>key_length</td><td>Length of the record key in bytes, or -1 if the record key is null.</td>
    </tr><tr>
        <td>key</td><td>The record key bytes.</td>
    </tr><tr>
        <td>value_length</td><td>Length of the record value in bytes, or -1 if the record value is null.</td>
    </tr><tr>
        <td>value</td><td>The record value bytes.</td>
    </tr><tr>
        <td>headers</td><td><p>Introduced in 0.11.0.0 for KIP-82, Kafka now supports application level record level headers. The Producer and Consumer APIS have been accordingly updated to write and read these headers.</p>
          <p>The size of the array is encoded as VARINT.</p></td>
    </tr><tr>
        <td>header_key_length</td><td>The length of the header key encoded in UTF-8.</td>
    </tr><tr>
        <td>header_key</td><td>The header key encoded as a UTF-8 string, without its length.</td>
    </tr><tr>
        <td>header_value_length</td><td>The length of the header value. In case the value is null, -1.</td>
    </tr><tr>
        <td>header_value</td><td>The value of this header.</td>
    </tbody></table>

<b>Compression</b>
<p>Kafka supports compressing messages for additional efficiency, however this is more complex than just compressing a raw message.
    Because individual messages may not have sufficient redundancy to enable good compression ratios, compressed messages must be sent in special batches
    (although you may use a batch of one if you truly wish to compress a message on its own). The messages to be sent are wrapped (uncompressed) in a MessageSet structure,
    which is then compressed and stored in the Value field of a single "Message" with the appropriate compression codec set.
    The receiving system parses the actual MessageSet from the decompressed value. The outer MessageSet should contain only one compressed "Message" (see KAFKA-1718 for details).</p>
<p>Kafka currently supports two compression codecs with the following codec numbers:</p>
<table class="data-table"><tbody>
    <tr><th>Compression</th>
        <th>Codec</th>
    </tr><tr>
        <td>None</td><td>0</td>
    </tr><tr>
        <td>GZIP</td><td>1</td>
    </tr><tr>
        <td>Snappy</td><td>2</td>
    </tbody></table>

<h4><a id="protocol_constants" href="#protocol_constants">Constants</a></h4>

<h5><a id="protocol_error_codes" href="#protocol_error_codes">Error Codes</a></h5>
<p>We use numeric codes to indicate what problem occurred on the server. These can be translated by the client into exceptions or whatever the appropriate error handling mechanism in the client language. Here is a table of the error codes currently in use:</p>
<!--#include virtual="generated/protocol_errors.html" -->

<h5><a id="protocol_api_keys" href="#protocol_api_keys">Api Keys</a></h5>
<p>The following are the numeric codes that the ApiKey in the request can take for each of the below request types.</p>
<!--#include virtual="generated/protocol_api_keys.html" -->

<h4><a id="protocol_messages" href="#protocol_messages">The Messages</a></h4>

<p>This section gives details on each of the individual API Messages, their usage, their binary format, and the meaning of their fields.</p>
<!--#include virtual="generated/protocol_messages.html" -->

<h4><a id="protocol_philosophy" href="#protocol_philosophy">Some Common Philosophical Questions</a></h4>

<p>Some people have asked why we don't use HTTP. There are a number of reasons, the best is that client implementors can make use of some of the more advanced TCP features--the ability to multiplex requests, the ability to simultaneously poll many connections, etc. We have also found HTTP libraries in many languages to be surprisingly shabby.</p>

<p>Others have asked if maybe we shouldn't support many different protocols. Prior experience with this was that it makes it very hard to add and test new features if they have to be ported across many protocol implementations. Our feeling is that most users don't really see multiple protocols as a feature, they just want a good reliable client in the language of their choice.</p>

<p>Another question is why we don't adopt XMPP, STOMP, AMQP or an existing protocol. The answer to this varies by protocol, but in general the problem is that the protocol does determine large parts of the implementation and we couldn't do what we are doing if we didn't have control over the protocol. Our belief is that it is possible to do better than existing messaging systems have in providing a truly distributed messaging system, and to do this we need to build something that works differently.</p>

<p>A final question is why we don't use a system like Protocol Buffers or Thrift to define our request messages. These packages excel at helping you to managing lots and lots of serialized messages. However we have only a few messages. Support across languages is somewhat spotty (depending on the package). Finally the mapping between binary log format and wire protocol is something we manage somewhat carefully and this would not be possible with these systems. Finally we prefer the style of versioning APIs explicitly and checking this to inferring new values as nulls as it allows more nuanced control of compatibility.</p>

    <script>
        // Show selected style on nav item
        $(function() { $('.b-nav__project').addClass('selected'); });
    </script>

<!--#include virtual="../includes/_footer.htm" -->
